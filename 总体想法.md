# 通用 AI 上下文工程系统（工作台）——项目原始描述（整合版）

> 说明：本文档是我基于三次头脑风暴对话记录（第一次 → 第二次 → 第三次）对“项目愿景、核心目标、关键机制、底层架构、产品形态与交互”的完整整合稿，作为后续 PRD / 技术设计 / 原型设计的**原始文本底稿**。  
> 关键词：上下文工程、变量系统、卡片化、AI Agent 编排、变更传播、审查循环、强制溯源、可视化配置、导入导出、微内核/插件化、通用工作台 + 官方模板。

---

## 1. 项目定位（最终版本）

我想做的不是一个“固定功能的小说写作工具”，而是一个**通用 AI 上下文工程系统**（可以理解为“工作台 / 元系统”）：

- **系统本身**：提供“配置、编排、执行、溯源、审查、可视化”的基础设施。
- **具体业务（例如 AI 中文长篇小说）**：只是系统中的一套**可导入/导出的配置与工作流**，并且可以作为程序内置的**官方模板（默认配置包）**。

这样设计的好处是：  
系统不会因为某一种写作方法或默认配置的变化而过时——**会过时的是配置包，而不是系统本体**。我希望把“正确的理念”变成“可被用户自定义复刻的系统能力”，并用高度模块化的底层设计作为最终兜底。

---

## 2. 为什么要做（最初动机 & 核心阻塞）

最初我从“AI 写中文网络长篇高质量爆款小说”出发，认为当前的核心阻塞主要是：

1. **稳定产出质量**（输出质量波动大）。
2. **长篇一致性问题**（人物、设定、时间线、状态持续一致非常难）。
3. **创意设计问题**（设定/剧情结构/伏笔回收等需要系统化支撑）。

我认为 AI（LLM）本质上是无状态的；要让 AI 在复杂长期任务中表现得“有状态、连贯、可控”，关键在于**上下文工程**。  
我把上下文工程抽象为“变量/不变量/缓慢变量”等结构化信息，并通过卡片化把上下文组织成工程系统，从而让任务背景、约束、历史和状态能持续发挥作用。

---

## 3. 思想演进（按三次对话顺序）

### 3.1 第一次对话：从“小说引擎”到“可自定义的元系统”

这一阶段我的核心主张是：

- **技术形态**：Rust + TypeScript 的 Web 端应用，Docker 部署，适配 Windows/macOS。
- **灵感来源**：既有规范与卡片体系（它们提供理念与框架），但产品要做到“像它们一样可完全自定义”，并提供一套默认配置保证开箱即用。
- **最高优先级**：没有“先做 MVP”的思路，目标是最佳体验与最佳效果；兜底来自**极其健硕的灵活度**（用户可视化配置 + 底层高度模块化）。
- **底层架构取向**：微内核 + 插件化/模块化，降低维护成本、支持持续迭代、允许用户自由编排工作流。
- **变量与上下文拼接**是系统核心：我强调“定义变量规则/引用规则/冲突预警/可视化配置/Token 预算可选”等能力都要开放给用户。

### 3.2 第二次对话：核心纠偏——上下文单元、变量驱动、变更传播、溯源图谱

这一阶段发生了几个关键“思想升级”：

- **上下文单元（Context Unit）统一抽象**：  
  - 原子变量 与 复合变量（卡片）是**同等地位**的上下文单元；引用关系完全自由（变量↔卡片、卡片↔卡片、变量↔变量）。
- **Agent 的真正组织方式**：不再是“按任务分类的 Agent”，而是**按变量/卡片责任划分**（变量驱动）。  
  Agent 既可以是“守护者”（被动响应变更/被使用），也可以是“执行者”（用户请求生产内容时主动执行）。
- **变更传播机制**：不是系统自动改一切，而是“通知 → 评估 → 输出理由 → 用户确认 → 落盘”，并沿引用层级继续传播。
- **四种确认模式**成为核心用户权利：严格 / 宽松 / 批量接受 / YOLO，并且可以对每个变量单独配置。
- **溯源系统的定位强化**：  
  - 这是系统灵魂级基础设施：所有产出必须强制溯源；  
  - 需要图结构展示（点和线），可点击节点查看关联与详情；  
  - 既服务用户理解/排错，也服务审查 Agent 的按需查询；  
  - 允许 Agent 为任务查询“非自己负责但相关”的变量，但必须有权限与确认机制。

### 3.3 第三次对话：项目重新定位——通用工作台 + 官方模板；补齐底层十大模块

这一阶段我把项目明确升级为：

- **先完成通用底层框架设计**，确保无致命漏洞、足够健硕、足够模块化、UI 足够可视化、用户定制性足够强。
- **小说系统作为官方模板**：等底层完成后，再按照底层规则制作并内置“AI 中文长篇小说配置包/工作流包”。
- **明确底层框架的十大模块**（变量、卡片、规则、Agent、溯源、审查、工作流、校验、导入导出、可视化 UI）。
- 补齐关键机制：
  - **状态卡（Context Card）**：当卡片内部变量都已绑定责任 Agent 后，这张卡就成为“可直接打包使用的上下文包”，负责它的 Agent 主要用于利用上下文产出内容。
  - **Agent 输出的四种格式**：输出变量 / 输出卡片 / 输出结果变量（固定产出）/ 输出卡片结果（固定卡片产出）。
  - **循环引用处理**：现实创作中一般不需要合理循环依赖；系统应检测、预警、给出重构建议，允许用户决策，并在运行时保护传播过程。
  - **系统级 Agent 的工具调用能力**：借鉴 IDE/代码助手的“按需查询”思想，让系统级 Agent 能主动探索系统结构（查询变量、依赖、反向依赖、搜索、溯源查询等）。

---

## 4. 最终整合后的系统定义（我希望系统“是什么”）

### 4.1 系统的“最小正确抽象”：上下文单元 = 变量 + 卡片

- **变量**：系统的原子数据单元。
- **卡片**：变量的组合（复合变量），用于封装上下文、组织信息、形成可复用的结构。
- 二者是同等地位的上下文单元，可以自由双向引用，形成依赖网络。

### 4.2 规则的本质：prompt 驱动 + 引用即依赖

我希望系统不做“过度复杂的规则 DSL”，而是把规则本质定义为：  
- **自然语言 prompt**（可被 AI 直接理解执行）  
- 当规则中引用 `{{变量}}` 或 `[[卡片]]` 时，系统自动建立依赖关系（形成图结构）。

并且（非常关键）规则要开放给用户可视化配置，用户能定义/修改：
- 变量如何生成（生成规则）
- 变量何时/如何变更（变更规则）
- 如何审查其正确性（审查规则）

### 4.3 变量的分类与维护方式（我真正关心的视角）

我更在意的不是“固定四类变量名”，而是变量在系统中的维护方式与生命周期：

- **不变量**：定死的，不需要 AI 维护。
- **一次性变量**：系统级 AI 辅助生成，用户确认后不再维护。
- **持续维护变量**：有专属 Agent 负责持续监控与更新。

在（小说模板）场景下，我也认可默认提供类似 CONST/SLOW/DYN/FACT 的变量类型体系，但它应当是**默认配置**，而不是底层强制约束；用户可以扩展/替换变量类型体系。

### 4.4 Agent 的分层职责（系统级 / 变量级 / 审查级）

#### A) 系统级 Agent（架构师）
系统级 Agent 的职责是“引导用户把需求变成可运行的系统配置”：
- 需求 → 板块/卡片（MECE 拆分） → 变量清单 → 规则草案 → 责任分配 → 工作流编排建议
- 并且系统级 Agent 应具备“按需查询系统结构”的工具能力（不全量加载，避免上下文爆炸）。

#### B) 变量级 Agent（守护者 + 执行者）
- **守护者（被动）**：负责的变量被引用/关联变量变动时触发，给出变更建议与理由，等待用户确认。
- **执行者（主动）**：用户请求生产内容时，基于变量/卡片 + prompt 生成内容。

#### C) 审查级 Agent（独立审查 + 循环审查）
- 每一次 AI 产出都应该可选地进入“单独审查”；同时保留“全局/全面审查”的总审查机制。
- 审查 Agent 默认继承生成 Agent 的规则作为上下文；用户可追加审查规则。
- 发现问题 → 反馈 → 修改 → 复查，循环直到无问题或人类叫停。
- 系统应提醒：审查 Agent 最好与生成 Agent 使用不同模型，减少同源盲点（但最终由用户决定）。

### 4.5 变更传播：通知 → 评估 → 确认 → 落盘 → 继续传播

当用户或 Agent 修改变量 A：
1. 找到第一层依赖 A 的变量集合（B/C/D...）
2. 通知各自负责 Agent 评估是否需要变更
3. 给出变更建议与理由 → 用户确认 → 落盘
4. 扩散到第二层依赖（E/F/G...），直到同步完成

这样做的目标是：
- 让系统在一致性上可控
- 避免 token 爆炸（按需触发 + 按层传播）
- 保持人类最终决策权

### 4.6 人类最终权利：四种确认模式 + 可配置到每个变量

系统默认所有变更都需要人类确认，但用户可按变量粒度配置确认策略：

- **严格模式**：每个变更都确认（默认）
- **宽松模式**：部分变量关闭人工确认（信任特定 Agent）
- **批量接受**：一次性批量接受多个变更（提效）
- **YOLO 模式**：全部交给 AI（快速迭代）

### 4.7 多模型/多后端：按变量/卡片配置模型来控制成本与质量

我希望用户可以：
- 为不同变量/卡片指定不同模型（复杂任务用强模型，简单任务用轻模型）
- 甚至配置不同 API 后端（OpenAI / Claude / Gemini / 本地模型等）
这样能在“质量/成本/速度”上让用户自主权最大化，也能进一步避免 token 成本成为系统瓶颈。

---

## 5. 溯源系统（系统灵魂）——“没有溯源的内容不允许进入系统”

我认为整个系统必须建立“强制溯源”策略：

- AI 生成的新内容（变量、卡片、正文、设定、任何产物）都必须记录：
  - 参与生成的变量/卡片输入
  - 生成时刻与版本
  - 变更链路（如果后续变更也要记录追加/更新溯源）
  - （可选）Agent 的推理过程

溯源系统要同时服务三类对象：
1. **用户**：可视化图谱（点和线），能拖拽、点击节点查看关联与详情，快速定位问题传播路径。
2. **审查 Agent**：按需查询溯源与依赖关系，作为审查依据。
3. **执行 Agent**：在用户允许时，可查询非自己负责但相关的变量/卡片，增强任务完成灵活性，但必须有权限与确认机制。

---

## 6. 输出与存储：Agent 的四种输出格式（非常关键）

我希望把“系统变量”与“Agent 产出记录”明确区分，并支持四种输出：

1. **输出变量**：更新目标变量的值（写回变量）。
2. **输出卡片**：按规则填充卡片各字段（写回卡片内部变量）。
3. **输出结果变量（固定结果）**：写入 Agent 的结果变量库（例如每一章正文）。
4. **输出卡片结果（固定卡片）**：写入 Agent 的卡片结果库（例如生成的一组角色卡片结果）。

无论哪一种输出，都必须进入溯源系统记录。

---

## 7. 底层框架：微内核/插件化 + 十大模块（通用系统骨架）

### 7.1 技术形态（我希望的实现方式）
- 前端：TypeScript / React（可视化编辑、设计器、工作台）
- 后端：Rust（核心内核、编译、事件总线、插件管理）
- 部署：Docker（Web 访问）；未来可选桌面端（例如 Tauri）但优先级取决于资源。

### 7.2 微内核 + 插件化（降低维护成本 & 支撑长期演化）
核心内核提供：
- Event Bus（事件驱动通信）
- Plugin Manager（插件管理）
- Config Manager（配置管理）

核心插件方向（可替换/可扩展）：
- Schema / Storage / Compile / LLM / Agent / Workflow 等

### 7.3 底层框架十大模块（最终整理）
1. 变量引擎：基础数据单元，可自定义类型  
2. 卡片引擎：变量组合，状态卡机制  
3. 规则引擎：prompt 驱动，变量引用  
4. Agent 层：执行、四种输出格式  
5. 依赖与溯源：图结构、查询 API  
6. 审查引擎：独立审查、循环审查  
7. 工作流引擎：节点、边、流程控制  
8. 校验引擎：可配置规则  
9. 导入导出：模板与数据序列化（配置包/工作流包）  
10. 可视化 UI：编辑器、设计器、图谱可视化

---

## 8. 可视化与交互（我对“最佳体验”的要求）

我希望系统做到“高复杂度能力，但可视化交互友好”，重点包括：

- **变量/卡片编辑器**：结构化字段、规则（prompt）编辑、依赖预览、溯源入口。
- **工作流编排器**：节点-边可视化，支持人类确认节点、循环审查节点、分支/条件/循环控制。
- **依赖图 / 溯源图可视化**：点线图，可拖拽、点击、局部展开；支持“从任意产出反查来源”和“从任意变量追踪影响面”。
- **确认中心**：展示变更建议 + 理由；支持四种确认模式；支持批量处理。
- **模型配置中心**：按变量/卡片绑定模型/API；展示调用统计；成本/质量可控。
- **Token 预算设置**：严格预算/软预算警告/质量优先不限制，并支持智能分块、滑动窗口等策略。

---

## 9. 导入导出（官方模板与生态的关键）

既然系统是“工作台”，导入导出就必须是一级能力：

- 导出：变量类型体系、卡片模板、规则模板、工作流模板、默认模型配置等打包成“配置包”。
- 导入：把配置包导入到新项目或其他用户环境中复用。
- 官方模板：基于 AI 中文长篇小说的一整套配置包/工作流包内置，用户开箱即用，也可二次改造。

---

## 10. 我对“系统底线”的要求（不妥协点）

1. **强制溯源**：没有溯源不允许进入系统。  
2. **人类最终决策权**：默认确认；四种模式全部开放且可配置到变量级。  
3. **高度模块化**：底层健硕、可替换、可扩展，长期不会被某一套方案绑死。  
4. **可视化优先**：复杂能力必须有对应 UI 支撑，不靠用户手写复杂配置才能用。  
5. **按需上下文**：避免 token 爆炸，用依赖图 + PACK 编译 + 事件触发控制规模。  
6. **没有 MVP 心态**：目标是最佳体验与效果；兜底来自灵活的底层与用户自定义。

---

## 11. 当前待进一步讨论/待定事项（先保留为开放问题）

> 以下是我在第三次对话里明确提出“需要再审视/适配”的点，作为后续完善的讨论清单：

- 变量类型体系：是否继续保留 SLOW / DYN 的区分？还是转为“属性维度体系”（可变性、触发方式等维度组合）  
- `owner` 概念：在通用系统里是否应该下沉到模板？或者区分“权威源”与“维护权”  
- 触发机制：是否需要 scheduled（定时触发），还是主要保留 manual / dependency 等触发  
- 结果变量/卡片结果 与系统变量（如 FACT）之间的关系边界与 UI 呈现方式  
- “底层规则 vs 模板规则”的边界：哪些校验规则必须成为底层能力，哪些放到模板配置包里  
- 如何定义“变量粒度边界”，避免变量/Agent 数量爆炸，同时仍然保持可控的精细度  

---

> 到这里，这份文档描述的是“我对项目的完整原始想法整合稿”。  
> 下一步我们可以在“开放问题清单”里逐项讨论，把它们逐步收敛成可落地的 PRD 与技术方案。
