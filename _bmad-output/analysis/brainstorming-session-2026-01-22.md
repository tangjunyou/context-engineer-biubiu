---
stepsCompleted: [1, 2, 3, 4]
inputDocuments: ['总体想法.md']
session_topic: '通用 AI 上下文工程系统设计完善与风险识别'
session_goals: '将构想从想法稿升级为可执行的系统设计蓝图'
selected_approach: 'progressive-flow'
techniques_used: ['First Principles Thinking', 'Morphological Analysis', 'Six Thinking Hats', 'Constraint Mapping', 'Failure Analysis', 'Idea Organization']
ideas_generated: 15
context_file: '总体想法.md'
technique_execution_complete: true
facilitation_notes: '用户展现深刻系统思维，主动识别核心失败风险并深入分析具体层面，提供完整的设计方案。用户强调核心信念：高度模块化底层 + 高度用户自定义 = 立于不败之地，以及代入场景思考、系统层面设计的方法论原则。用户明确品质追求：要做就做到最好。'
session_continued: true
continuation_date: '2026-01-28'
session_active: false
workflow_completed: true
completion_date: '2026-01-28'
team_context: '庞大且强劲的团队'
tech_stack: 'Rust (后端) + TypeScript (前端)'
validation_target: '完整的 UX/UI 设计，跑通小说创作场景'
---

# Brainstorming Session Results

**Facilitator:** 耶稣
**Date:** 2026-01-22

## Session Overview

**Topic:** 通用 AI 上下文工程系统（工作台）——设计完善与风险识别
**Goals:** 验证核心概念、收敛开放问题、发现潜在盲点、优化系统架构

### 项目最终目标

**双重交付：**
1. **通用 AI Agent 上下文工程软件** — 高度模块化、高度可定制的底层平台
2. **小说创作官方模板** — 基于通用平台的第一个官方应用模板

**核心信念：** 高度模块化底层 + 高度用户自定义 = 立于不败之地

> **概念澄清（后续 Product Brief 中进一步明确）：**
> - **高度模块化底层**（技术架构层）：技术选型和技术框架的高度模块化、可插拔、可扩展。后续无论是迁移数据库、升级功能、新增能力、修改设计、增加扩展性与外部连接，都无需全面翻新项目。这是**平台自身演进能力的保障**。
> - **高度用户自定义**（产品使用层）：平台可以极其灵活地自定义和DIY。官方模板存在问题时用户可自行调整，用户可在系统框架内天马行空地创造。这是**用户创造自由度的保障**。

**品质追求：** 要做就做到最好，追求完整性和卓越性，而非最小化交付

### Context Guidance

输入文档`/Users/jingshun/Desktop/AI 上下文工程可视化项目/总体想法.md`描述了一个通用 AI 上下文工程系统的完整构想，包括：
- 核心抽象：上下文单元（变量 + 卡片）
- Agent 分层职责（系统级/变量级/审查级）
- 变更传播与溯源系统
- 微内核+插件化底层架构
- 6个待讨论的开放问题

### Session Setup

用户希望通过系统化的头脑风暴将这个初步构想梳理成熟，使项目变得更加健壮和可落地。

---

## 核心设计原则

### 设计锚点：以小说场景为锚，但不陷入场景

本项目选择「中文长篇爆款网络小说创作」作为设计锚点。这是一种**设计方法论**，不是市场定位或功能限定。

**选择这个锚点的原因：**
1. **避免过度设计和闭门造车** — 有一个具体、复杂、真实的场景作为参照
2. **场景复杂度足够高** — 长篇小说涉及角色、世界观、情节线、时间线、关系网等多维度上下文管理
3. **最终交付清晰** — 通用平台 + 小说创作官方模板，目标明确

### 通用化设计方法论

**核心原则：代入场景思考问题，从系统层面设计解决方案**

当设计系统或遇到问题时，执行以下思维流程：

1. **代入场景具象化问题** — 将抽象问题放入小说创作场景中，看它如何具体表现
2. **从系统层面寻找解决方案** — 绝不针对小说场景设计定制化功能，而是思考：这个问题的本质是什么？通用的解决机制是什么？
3. **设计为通用化能力** — 解决方案必须是系统级的、可泛化的，小说场景只是它的一个应用实例
4. **验证泛化性** — 检验：这个设计能否直接适用于其他场景（游戏世界构建、企业知识库、法律文档管理等）？

**反模式警示：**
- ❌ 为「角色死亡」设计专门的系统功能 — 这是陷入场景
- ✅ 设计「状态变更触发级联更新」的通用机制，「角色死亡」通过模板配置实现 — 这是系统层面设计

### 开发节奏：阶段性目标与可测试验证

每个开发阶段应明确定义：
- **阶段目标**：本阶段要实现的完整能力
- **验证场景**：用小说创作场景中的具体用例测试
- **通过标准**：能力完整、体验到位、可泛化验证

具体的阶段规划将在后续步骤中详细制定。

---

## Phase 1: 发散探索（First Principles Thinking）

### 摘要
本次头脑风暴以第一性原理审视原始设计，形成了 **15 个核心设计决策**：
1) 统一"变量/卡片"为 Context Unit；
2) 引入 active/archived 生命周期与"晋升"机制；
3) 区分 Reference/Activation/Containment/Derivation 四类关系边；
4) Tag + Policy 分离（分类与行为正交）；
5) Authority Source vs Maintainer 分离；
6) Trigger = Event + Condition + 安全阀；
7) ChangeSet/ImpactSet/Reason 结构化确认；
8) Event Sourcing 作为溯源底座；
9) 配置包版本化 + Migration；
10) UI 范式：有机系统蓝图 + 让 AI "活"起来的核心愿景；
11) Agent 推理溯源 + 双视图权限配置；
12) Snapshot 用户化（命名快照 + 多种创建方式）；
13) Branch 分支管理（冲突解决 + 两阶段回溯重构）；
14) Query Scope + UI 约束选择模式；
15) 性能架构：全量存储 + 按需激活（Rust + TypeScript）。

---

## 背景：我们在挑战什么？
输入文档《总体想法.md》描述了一个通用 AI 上下文工程系统的初步构想。核心理念是：**LLM 本质无状态，要让 AI 在复杂长期任务中表现得“有状态、连贯、可控”，关键在于上下文工程。**
原始设计包含：变量/卡片、溯源系统、变量结果/卡片结果、四种确认模式等。我们用第一性原理挑战它们：是否存在更简洁且可扩展的抽象？

---

## 问题 1：变量和卡片真的是两个不同的东西吗？

### 问题背景
原始设计用“变量=原子”、“卡片=组合”的二元抽象。

### 挑战
> 「角色卡」能被「势力卡」引用为“变量”吗？若可以，二者的区分是否只是视角而非本质？

### 讨论
用户确认可以，并指出“变量们其实都是上下文包”。由此可见二者本质一致，只是粒度不同。

### 结论
**统一抽象：Context Unit（上下文单元）**
- 底层只有一种实体，可作为叶子或容器；
- “变量/卡片”留在 UI 作为视图/标签，而非底层结构。

**价值**：存储、权限、溯源、传播、查询、UI 复用同一机制，显著降复杂度。

---

## 问题 2：「变量」与「变量结果」的边界是什么？

### 问题背景
区分“变量=活数据”与“变量结果=固定产出”在实践易模糊。

### 挑战
> AI 写第三章正文引入新角色。应当：A) 仅留在结果；B) 自动提取为变量；C) 由用户决定是否提升？

### 讨论
- 否决 A：信息被锁在结果中，难以复用；
- 否决 B：自动膨胀，变量爆炸；
- 选择 C：保留人类最终决策权，按需纳入系统。

### 结论
**生命周期：active / archived + 晋升机制**
- `active`：参与依赖图、会触发传播、可修改；
- `archived`：只读存档、不触发传播、不入依赖网；
- **默认原则：AI 产出中新出现的实体/事实默认进入 `archived`，仅在确认后才可晋升为 `active`。**
- 支持 `archived → active`“晋升”，必须经确认并记录溯源。

**价值**：避免膨胀（默认不进系统网络）、保留决策权、不丢信息、过程可追溯。

---

## 问题 3：引用即依赖，但所有关系都是同一种“边”吗？

### 问题背景
原始设计把所有关系都视作“引用边”，易导致传播混乱与可视化负担。

### 挑战
> “包含关系”和“被规则引用”是同一种吗？“触发维护”和“派生来源”又是同一种吗？

### 讨论
不同关系语义与传播行为不同，需要区分与可视化过滤。

### 结论
**四种边类型**
| 边类型 | 语义 | 传播行为 | 示例 |
|---|---|---|---|
| Reference | 规则/Prompt 中引用 | ✅ 触发下游重新评估 | `{{角色A}}` 被写作规则引用 |
| Activation | A 变化激活 B 维护流程 | ✅ 触发 Maintainer 工作 | 角色死亡 → 激活相关状态更新 |
| Containment | 结构包含（父子） | ⚠️ 仅向上冒泡状态变化（脏标记），不向下游传播；是否进一步触发维护需显式规则 | 角色卡包含“姓名/性格” |
| Derivation | 派生/溯源 | ❌ 仅记录来源，不参与传播 | 第三章正文派生自角色卡+大纲 |

**价值**：UI 可按边类型过滤，传播规则清晰，契合“神经系统”隐喻。

---

## 问题 4：类型体系（CONST/SLOW/DYN）在统一抽象下怎么办？

### 问题背景
原始设计延续了传统变量类型分类：CONST（常量）、SLOW（缓慢变化）、DYN（动态）、FACT（事实）。这种分类体系假设变量有固定的“本质类型”。

### 挑战
> 如果一切都是 Context Unit，固定的四分类还有意义吗？一个变量能不能既是“人物相关”又是“高风险需审查”？

### 讨论
- 固定分类的问题：一个变量只能属于一种类型，但实际场景中往往需要多维度描述；
- 用户反馈：应该通过“标题、备注和 #标签”来分类，而非强制类型；
- 进一步区分：分类（是什么）和行为（怎么对待）是两件事，不应耦合。

### 结论
**Tag + Policy 分离**
- Tag 管“是什么”（如 `#人物` `#世界观` `#关键事实` `#不可变`）；
- Policy 管“怎么对待”（确认模式、可写 Agent、可用模型等）。

**Policy 结构示例：**
```yaml
Policy:
  confirmation_strategy: confirm_required  # immediate / confirm_required / batch_queue / auto_trusted
  allowed_maintainers: [Agent-A, Agent-B]
  allowed_models: [claude-3, gpt-4]
  requires_review: true
  max_auto_propagation_depth: 3
```

**价值**：分类与行为正交，最大灵活与可迁移性。

---

## 问题 5：`owner` 概念如何在通用系统中定义？

### 问题背景
原始设计《总体想法.md》第 11 节将 `owner` 概念列为开放问题：「在通用系统里是否应该下沉到模板？或者区分“权威源”与“维护权”」。

### 挑战
> 一个 Context Unit 的 owner 是指“谁有权修改它”还是“最终以谁的版本为准”？如果 AI Agent 提出修改建议，但人类是最终权威，如何表达这种关系？

### 讨论
- “owner”一词含义模糊：可能指创建者、维护者、或权威来源；
- 实际场景：一个角色设定可以是“人类为最终权威”+“AI Agent 负责监控和建议修改”；
- 需要分离两个概念：谁说了算（冲突时）vs 谁负责日常维护。

### 结论
**Authority Source vs Maintainer 分离**
- Authority Source：冲突时以谁为准（人类/外部文档/系统/Agent）；
- Maintainer：谁负责提更新建议（Agent/人类/规则）。

**价值**：消除歧义，权限/职责更精确。

---

## 问题 6：触发机制够不够？条件/批量/链式爆炸如何处理？

### 问题背景
原始设计列出四种触发类型：用户输入、关联变量变更、定时触发、外部调用。这些是否足够覆盖实际场景？

### 挑战
> 1. 条件触发怎么办？比如“当章节数 > 10 时自动触发某流程”。
> 2. 批量触发怎么办？用户选中一组变量统一更新。
> 3. 链式爆炸怎么办？A→B→C→D 形成长链时，如何防止无限传播？

### 讨论
- 四种触发本质是**事件源**，不是触发机制本身；
- 条件触发 = 事件源 + 条件过滤，不需要新增“第五种触发”；
- 批量触发 = 多个事件的聚合处理，应在确认中心支持；
- 链式爆炸需要系统级安全阀，而非依赖用户配置。

### 结论
**Trigger = Event + Condition + 安全阀**
- 事件源：user_input / unit_changed / time_tick / external_call / 自定义；
- 条件：可选的过滤规则，满足时才触发；
- 安全阀：最大传播深度、频率限制/去抖、`impactSet` 超阈强制人工确认。

**价值**：可扩展（不用加新触发类型）、不易过时、安全可控。

---

## 问题 7：确认机制如何结构化？

### 问题背景
原始设计提出四种确认模式：严格、宽松、批量接受、YOLO。这是正确方向，但“确认”的数据结构是什么？

### 挑战
> 用户在确认时需要知道什么？只是“接受/拒绝”吗？还是需要看到完整的变更上下文？

### 讨论
- 如果只是“是/否”开关，用户无法做出明智决策；
- 用户需要知道：要改什么（ChangeSet）、会影响谁（ImpactSet）、为什么要改（Reason）；
- 四种模式本质是“谁可以自动提交 ChangeSet”和“什么情况必须人工介入”的策略配置。

### 结论
**ChangeSet + ImpactSet + Reason**
- ChangeSet：要改哪些单元、改成什么（可拆分接受）；
- ImpactSet：会影响哪些下游（按层级/边类型计算）；
- Reason：为何而改（触发事件 trigger、证据引用 evidence refs、可选 agent rationale）。
- 执行策略：immediate / confirm_required（默认）/ batch_queue / auto_trusted。

**价值**：让确认基于完整上下文，不是“是/否”开关；策略可按 Tag/Policy 精细配置。

---

## 问题 8：溯源系统应当是模块还是地基？

### 问题背景
原始设计将溯源称为“系统灵魂”，并列为十大模块之一。但这种定位是否足够？

### 挑战
> 如果溯源只是“模块之一”，它就可能被绕过或事后补充。如何让“强制溯源”成为架构必然而非约定？

### 讨论
- 溯源不应是“事后记录”，而应是“系统事实的定义方式”；
- Event Sourcing 架构：当前状态 = 所有事件的折叠结果；
- 这样溯源不是可选功能，而是数据存储的本质——无法绕过。

### 结论
**Event Sourcing 作为溯源底座**
- Event Store：不可变事件记录（谁在何时因何对哪些单元做了什么）；
- Projection：当前状态视图（由事件计算得出）；
- Snapshot：性能优化的状态快照；
- 统一 Query API：UI 和 Agent 共用同一套查询接口。

**价值**：强制溯源（架构必然）、时间旅行、Undo/Redo、Diff 对比、统一查询模型。

---

## 问题 9：模板/配置包会过时，如何安全升级？

### 问题背景
核心哲学是“系统不过时，模板可过时”。但如果官方小说模板升级了 schema，用户项目怎么办？

### 挑战
> 一年后你升级官方模板，用户的旧项目能否平滑迁移？如果不能，核心愿景就会被破坏。

### 讨论
- 没有 migration 机制，模板升级会导致用户项目崩溃；
- 这不是“以后再考虑”的问题，必须从第一天设计；
- 配置包需要版本号 + 迁移规则。

### 结论
**版本化 + Migration**
- 配置包声明 `schemaVersion`；
- 提供从旧版本的迁移脚本/规则（哪怕初期很简单）；
- 系统在加载配置包时检测版本，自动或提示运行迁移。

**价值**：兑现“系统不过时，模板可过时”的核心承诺；用户项目可安全升级。

---

## 问题 10：与 Dify 的本质区别是什么？（范式转换）

### 范式对比
| 维度 | Dify 范式 | 本项目范式 |
|---|---|---|
| 构建思维 | 流程图：A→B→C | 有机系统：设计器官与相互作用 |
| 核心问题 | 下一步做什么 | 系统需要哪些器官，如何协同 |
| 执行模型 | 顺序/并行 | 事件驱动 + 相互响应 |
| 变更模型 | 手动触发下一步 | 变更沿“神经系统”传播 |

### 结论（UI 必须体现）
- 主视图="系统蓝图"，卡片="器官"，连线="神经/血管"，溯源="神经系统扫描"；
- 构建起点是"需要哪些器官"，而非"第一步做什么"。

### 深层愿景：让 AI "活"起来

本项目的最高目标不只是"更好的工作流编排"，而是构建**可以自主运转的 AI 有机体**：

| 层面 | Dify 等工作流平台 | 本项目（上下文工程平台） |
|------|-------------------|---------------------------|
| 产品定义 | 工作流是产品 | 有机体是产品，工作流只是运行模式之一 |
| 运行方式 | 被动执行（等待触发） | 持续"活着"（响应、协调、自主运转） |
| 状态来源 | 状态存在于流程节点之间 | 状态内化于有机体本身 |
| 核心洞察 | 编排执行顺序 | **上下文工程赋予 AI 状态** |

**关键理念：**
> AI 本质无状态。是精密的上下文工程设计让 AI 有了状态——让 AI Agent 真正"活"了起来。

**设计影响：**
- UI/UX 必须引导用户用"设计有机体"而非"编排流程"的思维
- 系统可以运行在两种模式：
  - **协作模式**：人机协同，按需触发，产出结果（如小说创作）
  - **自主模式**：有机体持续自主运转，响应环境变化

---

---

## 问题 11：Agent 推理过程如何纳入溯源？

### 问题背景
每个变量/卡片可以绑定 AI Agent 负责。当 Agent-A 更新变量 X 后，关联变量的 Agent-B 会收到通知。Agent-B 可能需要查询“Agent-A 为什么更新 X”来做出更准确的判断。

### 挑战
> 溯源系统是否需要记录 Agent 的完整推理过程？Agent 对溯源系统的查询本身是否也要记录？

### 讨论
- 底层设计理念：**底层记录一切，用户层选择性开放**
- Agent 的完整推理过程（Chain of Thought）应该记录
- Agent 的溯源查询行为本身也应该记录
- 这符合核心理念：高度模块化底层 + 高度用户自定义 = 立于不败之地

### 结论
**Event 结构扩展：**
```yaml
Event:
  # 基础信息
  timestamp, actor, action, subject, changes
  
  # Agent 推理上下文（新增）
  reasoning:
    trigger_event: 触发此次更新的事件
    inputs_read: Agent 读取了哪些 Context Unit
    traceability_queries: Agent 做了哪些溯源查询
    chain_of_thought: Agent 完整推理过程
    conclusion: 最终结论
  
  # 传播信息（新增）
  notifications_sent: 通知了哪些下游 Agent
```

**Agent 溯源查询 API：**
| 查询 | 权限级别 |
|------|----------|
| `getLatestChange(X)` | 基础 |
| `getChangeTrigger(X)` | 标准 |
| `getAgentRationale(X)` | 高级 |
| `getInputsConsidered(X)` | 高级 |
| `traceBack(X, depth)` | 完整 |

**关键原则：**
- 底层 Event Store 记录一切（推理过程、查询行为、通知记录）
- 用户可配置每个 Agent 的查询权限级别
- 用户可在 Agent 规则（Prompt）中指定何时调用溯源查询

**权限配置的双视图同步：**

用户可以从两个视图配置 Agent 权限，底层数据同步：

| 视图 | 入口 | 配置角度 |
|------|------|----------|
| Context Unit 编辑视图 | 编辑变量/卡片时 | 「这个单元允许哪些 Agent 访问」 |
| Agent 管理视图 | Agent 总管理界面 | 「这个 Agent 可以访问哪些单元」 |

**同步原则：**
- 底层是单一数据源
- 任一视图的修改实时反映到另一视图
- 用户按习惯选择入口，无需记忆「正确的配置位置」

**价值：**Agent 间协作有据可查、可追溯、可调试；用户可按需控制复杂度。

---

## 问题 12：如何支持项目级的版本管理与回溯？

### 问题背景
复杂项目（如长篇小说、大型软件项目、法律案件等）需要在不同阶段保存进度，并能回溯到历史状态。Event Sourcing 提供了事件级的历史记录，但用户需要更高层次的「项目快照」能力。

### 挑战
> 用户需要：1) 定期保存项目完整状态；2) 回溯到某个历史节点；3) 从历史节点分叉继续工作而不丢失原进度。

### 讨论
- Event Sourcing 已有 Snapshot 概念（用于性能优化），但不是用户可操作的；
- 用户需要的是「命名的、可管理的」快照，类似 Git 的 commit；
- 回溯后的操作需要支持多种模式：查看、继续、重构。

### 结论
**Snapshot 升级为用户可操作的版本管理能力**

```yaml
Snapshot:
  id: "snapshot-uuid"
  name: "第49章定稿"          # 用户命名
  created_at: timestamp
  created_by: user | system | schedule
  branch: "main"
  description: "完成第49章，角色关系稳定"  # 可选备注

  # 创建方式
  triggers:
    - manual: 用户手动创建
    - scheduled: 定时自动创建（如每小时/每天）
    - event: 特定事件触发（如「章节标记为完成」）
```

**用户操作：**
| 操作 | 说明 |
|------|------|
| 创建快照 | 保存当前项目完整状态 |
| 查看快照 | 只读浏览历史状态 |
| 回溯到快照 | 将项目状态恢复到该快照（详见问题 13 的分支处理） |
| 对比快照 | Diff 两个快照之间的变化 |

**价值**：项目级版本管理、安全回溯、进度可视化。

---

## 问题 13：回溯后如何处理？（分支管理）

### 问题背景
当用户回溯到历史快照后，有多种可能的后续操作。需要支持 Git 式的分支管理。

### 挑战
> 用户回溯到「第30章定稿」后，可能想：A) 查看当时状态；B) 从此处分叉继续，保留原进度；C) 回滚并删除后续进度；D) 修改后触发全链路重构。

### 讨论
- 简单的「撤销/重做」不够，需要分支概念；
- 分支允许实验性修改而不影响主线；
- 「回溯重构」是特殊场景：修改历史节点后，所有相关变量需要重新评估。

### 结论
**Branch（分支）作为平台能力**

```yaml
Branch:
  id: "branch-uuid"
  name: "主线" | "第30章重写实验"
  parent_snapshot: "snapshot-xxx"  # 从哪个快照分叉
  created_at: timestamp
  status: active | archived | merged
```

**分支操作：**
| 操作 | 说明 |
|------|------|
| 创建分支 | 从任意快照创建新的独立演进线 |
| 切换分支 | 在不同分支间切换工作上下文 |
| 归档分支 | 不再活跃但保留历史 |
| 合并分支 | 将一个分支的变更合并到另一个（需确认冲突） |

**回溯后的操作模式：**
| 模式 | 行为 |
|------|------|
| 查看 | 只读浏览，不创建分支 |
| 分叉继续 | 创建新分支，原分支保留 |
| 回滚删除 | 回到该快照，删除后续事件（危险操作，需二次确认） |
| 回溯重构 | 在该快照上修改，触发 Activation Edge 全链路重新评估，所有下游变更需用户逐一确认 |

**分支合并的冲突解决：**

当两个分支都修改了同一个 Context Unit 时，需要解决冲突：

**冲突解决策略：**
| 策略 | 行为 | 适用场景 |
|------|------|----------|
| `latest_wins` | 后修改的版本胜出 | 低风险、快速合并 |
| `source_wins` | 源分支版本胜出 | 信任源分支 |
| `target_wins` | 目标分支版本胜出 | 保守合并 |
| `manual_review` | 进入确认中心，用户逐个决定 | 高风险或重要变更 |
| `side_by_side` | 并排展示差异，用户选择或编辑 | 需要精细控制 |

**默认策略：** `manual_review`（保留人类决策权）

---

**回溯重构的两阶段方案：**

当用户选择「回溯重构」时，系统采用两阶段处理以降低复杂度：

**阶段一：机械批量替换**
```yaml
场景: 名称变更、术语统一等机械性修改
流程:
  1. 系统列举所有受影响的位置
  2. 用户选择：把 [旧值] 批量替换为 [新值]
  3. 系统在该分支上全量执行替换
  4. 记录为单个事件（包含所有变更位置）
  
日常可用: true  # 批量替换也作为日常功能提供
```

**阶段二：时序逐层重构**
```yaml
场景: 语义性变更，需要 AI/人类重新评估
规则:
  - 必须按时间顺序逐层处理（保证因果一致性）
  - 每层的 Maintainer Agent 评估是否需要变更
  - 人类参与决策

流程:
  1. 系统计算影响链（按时间/依赖层级排序）
  2. 显示警告：「将影响 X 个单元，预计需要 Y 轮确认」
  3. 逐层推进：第 N 层完成后才进入第 N+1 层
  4. 每层可选：逐个确认 / 本次批量同意 / YOLO 模式
  5. 关联的 archived 结果标记为「待审查」
```

**设计原则：**
- 机械替换先行，减少后续语义评估数量
- 时序约束保证因果一致性
- 保留人类决策权，但提供效率选项

**价值**：安全的实验性修改、完整的版本历史、可控的大规模重构。

---

## 问题 14：如何引用历史状态或其他分支的变量值？（Query Scope）

### 问题背景
在某些场景下，用户需要引用的不是变量的「当前值」，而是「某个历史快照的值」或「另一个分支的值」。

### 挑战
> 例：写第50章时，需要引用「第49章定稿时」的角色状态，而非当前编辑中的状态。如何让用户配置这种引用？

### 讨论
- 这是一个查询作用域问题；
- 不应要求用户写代码，需要预定义的查询模式；
- 应可在 Prompt/规则设计时可视化配置。

### 结论
**Query Scope（查询作用域）作为引用语法扩展**

**预定义查询模式：**
| 模式 | 语法 | 含义 |
|------|------|------|
| 默认（当前） | `{{变量}}` | 当前分支最新状态 |
| 指定快照 | `{{变量 @snapshot="名称"}}` | 指定快照时的状态 |
| 指定分支 | `{{变量 @branch="名称"}}` | 指定分支的最新状态 |
| 相对位置 | `{{变量 @snapshot=-1}}` | 上一个快照的状态 |

**在可视化界面配置：**
用户在配置 Prompt 引用变量时，可选择：
- 「使用当前值」（默认）
- 「使用快照值」→ 选择快照
- 「使用分支值」→ 选择分支
- 「使用相对快照」→ 输入偏移量

**UI 约束选择模式：**

**核心原则：凡是有限集合的选择，都用 UI 约束而非自由输入。**

用户在引用变量时的交互流程：
1. 点击「添加引用」
2. 选择查询范围：「当前」/「指定快照」/「指定分支」
3. 弹出选择器面板：
   - 滑动浏览可用的变量/卡片
   - 或搜索查询
   - 只显示在所选范围内存在的项
4. 选中后，系统自动生成语法

**该模式的广泛应用：**
| 场景 | 自由输入（❌ 不用） | 约束选择（✅ 采用） |
|------|---------------------|---------------------|
| 引用变量 | 手写 `{{变量名}}` | 从列表选择 |
| 选择快照 | 手写快照名 | 从快照列表选择 |
| 配置 Agent | 输入 Agent ID | 从 Agent 列表选择 |
| 绑定模型 | 输入模型名 | 从可用模型选择 |

**价值：**
- 杜绝无效引用（不存在的变量、快照等）
- 降低学习成本（无需记忆命名规则或语法）
- 提高配置效率

**Agent 规则中的查询配置：**
```yaml
# 在 Agent 规则中指定其查询范围
agent_config:
  default_query_scope: latest  # 默认查当前
  allowed_scopes: [latest, snapshot, branch]  # 允许的查询范围
  restricted_branches: ["实验分支"]  # 禁止访问的分支
```

**价值**：灵活引用历史/分支状态、无需写代码、权限可控。

---

## 问题 15：如何保证大规模项目的性能？

### 问题背景
Event Sourcing + Snapshot + Branch 组合下，长期运行的项目（如长篇小说创作一年）可能产生数万个事件、数百个快照、多个分支。如何保证查询和操作的性能？

### 挑战
> 如果每次查询都要重放所有事件，系统会变得极慢。如何在「全量存储」和「快速查询」之间取得平衡？

### 讨论
- 核心理念：**全量无损存储 + 按需激活查询范围**
- 技术栈：Rust（性能关键路径）+ TypeScript（UI 和业务逻辑）
- 存储层保留一切，查询层按需加载

### 结论
**性能架构：全量存储 + 按需激活**

**技术分层：**
```
┌─────────────────────────────────────┐
│          TypeScript 层              │
│   (UI, 业务逻辑, API 编排)          │
└──────────────┬──────────────────────┘
               │ FFI / WASM
┌──────────────▼──────────────────────┐
│            Rust 层                  │
│   (Event Store, 查询引擎, 状态投影) │
└─────────────────────────────────────┘
```

**Rust 负责的性能关键路径：**
| 功能 | 技术手段 |
|------|----------|
| Event 存储 | Append-only，零拷贝写入 |
| 快照生成 | 增量快照（只记录变化） |
| 状态投影 | `最近快照 + 后续事件` 重建 |
| 范围查询 | 按 Unit ID / 时间 / 边类型索引 |

**按需激活的查询逻辑：**
```
查询某 Unit 在某 Snapshot 的状态:
  1. 找到最近的基准快照
  2. 只加载该 Unit 相关的后续事件（非全量）
  3. 重放这些事件得到目标状态
```

**核心原则：**
- 存储层：全量、无损、永不删除
- 查询层：按需、范围限定、惰性加载

**价值**：历史完整可追溯、查询性能可控、支持大规模长期项目。


## Phase 1 总结：15 个核心设计决策

| # | 决策 | 核心理由 |
|---|---|---|
| 1 | 统一为 Context Unit | 降复杂、机制复用 |
| 2 | active/archived + 晋升 | 避免膨胀、保决策权、可追溯 |
| 3 | 四类边（Reference/Activation/Containment/Derivation） | 传播清晰、可视化友好 |
| 4 | Tag + Policy | 分类/行为正交、可迁移 |
| 5 | Authority vs Maintainer | 权限与职责精确化 |
| 6 | Event + Condition + 安全阀 | 可扩展与安全控制 |
| 7 | ChangeSet/ImpactSet/Reason | 基于完整信息的确认 |
| 8 | Event Sourcing | 溯源为地基、时间旅行 |
| 9 | 包版本化 + Migration | 模板安全升级 |
| 10 | UI 范式 + 核心愿景 | 让 AI "活"起来，有机体思维 |
| 11 | Agent 推理溯源 + 双视图权限 | 底层记录一切、灵活配置入口 |
| 12 | Snapshot 用户化 | 版本管理、可回溯、可命名 |
| 13 | Branch + 冲突解决 + 两阶段重构 | 安全分支、可控重构 |
| 14 | Query Scope + UI 约束选择 | 灵活引用、杜绝无效输入 |
| 15 | 全量存储 + 按需激活 | 历史完整、查询高效 |

---

## 待议事项（后续 Phase 讨论）

**✅ 已解决：术语冲突**
- 原“Trigger 边”已改名为 **Activation Edge**（表示“A 变化激活 B 维护流程”的关系）
- **Trigger Rule**：Event + Condition + 安全阀（规则配置对象）
- 两者现已明确区分

**✅ 已补充：Containment 边的向下广播规则**

**ContainmentEdge 的可选配置：**
```
├── bubbleUp: true（默认）——子级变化向上冒泡脏标记
├── broadcastDown: false（默认）——父级变化不自动向下广播
└── broadcastRules: [可选] 定义哪些父级属性变化时广播给哪些子级
```

**配置示例：**
```yaml
# 势力卡的 Containment Policy
containment:
  broadcastRules:
    - when: "阵营立场" changed
      notify: all children with tag #角色
      action: suggest_review  # 建议审查，而非强制更新
```

**设计原则：**
- 默认行为简单（不广播），降低认知负担
- 高级用户可配置复杂规则
- 广播动作默认为 `suggest_review`（建议审查），而非 `force_update`（强制更新），保留人类决策权

---

## Technique Execution Results

**Failure Analysis:**

- **Interactive Focus:** 识别系统可能失败的两个核心维度——架构模块化与用户自由度；后扩展至产品体验与协作机制
- **Key Breakthroughs:** 
  - 风险 #1: 核心概念（边类型、状态）缺乏可扩展性
  - 风险 #2: Event Sourcing 作为唯一底座可能不适用所有场景
  - 风险 #3: active/archived 二元生命周期可能不够
  - 风险 #4: Authority/Maintainer 二元权限可能不足
  - 风险 #5: 一次性确认假设限制复杂确认流程
  - 风险 #6: 缺乏用户可定义的上层抽象（Relation Template、Unit Schema、Behavior Package）
  - 风险 #7: 缺乏轻量级运行时控制层（临时覆盖、Dry-run、暂停状态、轻量沙盒）
  - 风险 #8: 上手体验与学习曲线（三层体验架构、概念延迟暴露、UI双轨设计）
  - 风险 #9: Agent 错误级联与批量恢复（因果链视图、批量操作、高语义检测）
  - 风险 #10: 多人协作机制（冲突处理、确认归属、通知机制、权限模型）
  - 待设计 #1: 开放生态 / 外部连接能力
  - 项目框架补充: 三种运行模式（自动化模式 / 单人工作台 / 多人工作台）
- **User Creative Strengths:** 系统性思维、主动深入分析、清晰的问题分解与结构化表达、提供完整设计方案
- **Energy Level:** 高度投入，主动提供详细分析和具体建议，持续深入探索

**Overall Creative Journey:** 从宏观的两大核心失败风险出发，逐层深入到具体设计决策审视和用户场景分析，进而扩展到产品体验和协作机制维度，最终产出 10 个关键风险、1 个待设计领域、1 个项目框架补充。

### Creative Facilitation Narrative

_用户首先识别出项目可能失败的两个核心原因：架构不够模块化和功能设计不够灵活。在架构模块化探索中，通过尖锐场景问题分析了 5 个高风险的硬编码假设。在用户自由度探索中，用户主动深入分析，识别出「缺乏上层抽象」和「缺乏轻量级运行时控制」两个关键盲点，并给出了具体的缺失能力清单和建议机制。随后探索扩展到产品体验维度，用户提供了完整的「三层体验架构」和「第一个哇时刻」设计方案。在 Agent 错误级联探索中，用户分析了现有保护与缺口，提出因果链管理器等补充设计。最后在多人协作维度，用户补充了三种运行模式框架，并针对同时编辑、确认归属、通知机制等问题提供了完整的设计方案。_

### Session Highlights

**User Creative Strengths:** 系统性思维、主动深入分析、清晰的问题分解和结构化表达、能够提供完整可执行的设计方案
**AI Facilitation Approach:** 提出尖锐场景问题，引导用户思考具体的失败情境，逐层深入不同维度
**Breakthrough Moments:** 「缺乏上层抽象」、「缺乏轻量级运行时控制」、「三层体验架构」、「三种运行模式框架」、「多人协作完整设计」
**Energy Flow:** 持续高能量，用户主动提供详细分析和结构化建议，每个问题都给出完整解决方案

---

## Phase 2 详细记录：Failure Analysis

### 两大核心失败风险维度

用户识别出项目可能失败的两个核心原因：

1. **底层技术架构不够模块化** → 导致修复和迭代非常缓慢
2. **功能设计不够灵活** → 用户没有办法自由 DIY，自由创造各种可能

---

### 风险清单总览

| # | 风险 | 维度 | 等级 |
|---|------|------|------|
| 1 | 核心概念的可扩展性 | 架构模块化 | 🔴 高 |
| 2 | Event Sourcing 唯一性 | 架构模块化 | 🔴 高 |
| 3 | 二元生命周期 | 架构模块化 | 🟡 中 |
| 4 | 二元权限模型 | 架构模块化 | 🟡 中 |
| 5 | 一次性确认假设 | 架构模块化 | 🟡 中 |
| 6 | 缺乏上层抽象 | 用户自由度 | 🔴 高 |
| 7 | 缺乏轻量级运行时控制 | 用户自由度 | 🟡 中 |
| 8 | 上手体验与学习曲线 | 产品体验 | 🔴 高（但可控） |
| 9 | Agent 错误级联与批量恢复 | 产品体验 | 🟡 中 |
| 10 | 多人协作机制 | 协作机制 | 🟡 中 |

---

### 维度一：架构模块化（风险 #1-5）

#### 风险 #1: 核心概念的可扩展性

**风险评级：** 🔴 高（架构地基，改动成本极高）

**核心问题：** 边类型、生命周期状态等「核心概念」被硬编码在系统各处，缺乏统一的扩展机制，一旦需要修改将触发全系统重构。

**当前设计中的硬编码概念：**

| 核心概念 | 当前实现 | 硬编码位置 | 扩展难度 |
|----------|----------|------------|----------|
| 边类型 | 四种固定类型（Reference/Activation/Containment/Derivation） | 存储层、传播引擎、UI | 🔴 高 |
| 生命周期状态 | active/archived 二元 | 状态机、权限逻辑、传播规则 | 🟡 中 |
| 触发事件类型 | user_input/unit_changed/time_tick/external_call | 事件处理器、规则引擎 | 🟡 中 |
| 确认策略 | immediate/confirm_required/batch_queue/auto_trusted | 确认中心、Policy 配置 | 🟢 低 |

**尖锐场景：**

> 半年后发现「四种边类型」有根本性缺陷——需要第五种边（如「互斥关系 Exclusion」表示 A 和 B 不能同时为真），或 Containment 和 Activation 的边界定义错误需要重新划分。

**影响分析：**

| 受影响模块 | 影响程度 | 具体影响 |
|------------|----------|----------|
| 存储层 | 🔴 高 | Event 结构需要支持新边类型、索引重建、查询逻辑修改 |
| 传播引擎 | 🔴 高 | 传播规则需要重写、安全阀逻辑需要适配 |
| UI 可视化 | 🟡 中 | 新增边类型图标、过滤器选项、颜色配置 |
| Agent 行为 | 🟡 中 | Agent 规则中的边类型判断逻辑需要更新 |
| 配置/模板 | 🟢 低 | 配置 schema 更新、模板迁移 |

**建议补充的设计：**

**1. 核心概念注册机制**

```yaml
# 边类型注册示例
EdgeTypeRegistry:
  builtin_types:
    - name: Reference
      propagation: trigger_downstream_evaluation
      ui: { color: "#4A90D9", icon: "link" }
    - name: Activation
      propagation: trigger_maintainer_workflow
      ui: { color: "#7B68EE", icon: "zap" }
    - name: Containment
      propagation: bubble_up_dirty_flag
      ui: { color: "#50C878", icon: "folder" }
    - name: Derivation
      propagation: none_record_only
      ui: { color: "#808080", icon: "git-branch" }
  
  extension_api:
    # 用户/模板可注册新边类型
    register_edge_type:
      name: "Exclusion"  # 互斥关系
      propagation: "notify_conflict_check"
      ui: { color: "#FF6B6B", icon: "x-circle" }
      validation: "source.value AND target.value => conflict"
```

**2. 抽象层设计原则**

| 层级 | 职责 | 可扩展性 |
|------|------|----------|
| **Core Interface** | 定义边/状态的抽象接口（IEdgeType, ILifecycleState） | 稳定，不变 |
| **Builtin Implementation** | 四种边类型、二元状态的默认实现 | 内置，可覆盖 |
| **Extension Layer** | 用户自定义类型注册、模板定义的领域特定类型 | 完全开放 |

**与核心架构的关系：**

这**需要从第一天设计**，而非事后补充。核心概念的注册机制应该是架构的一部分，而非「可选扩展」。如果底层硬编码了四种边类型，后期改造成本极高——需要修改存储 schema、重写传播引擎、更新所有 UI 组件。

---

#### 风险 #2: Event Sourcing 作为唯一底座

**风险评级：** 🔴 高（架构地基，几乎无法更换）

**核心问题：** Event Sourcing 被设定为系统唯一的数据存储范式，但并非所有场景都适合 ES，某些高频/简单场景可能被 ES 的复杂度拖累。

**Event Sourcing 的优势与局限：**

| 维度 | ES 优势 | ES 局限 |
|------|---------|----------|
| 溯源能力 | ✅ 完整历史记录、时间旅行 | — |
| 审计合规 | ✅ 不可变日志、完整审计链 | — |
| 调试能力 | ✅ 可重放、可追溯因果 | — |
| 查询性能 | — | ❌ 需要 Projection，复杂查询成本高 |
| 开发复杂度 | — | ❌ 学习曲线陡峭，早期迭代慢 |
| 高频写入 | — | ❌ 实时协作编辑可能产生大量事件 |
| 批量操作 | — | ❌ 大批量导入需要生成海量事件 |

**尖锐场景：**

| 场景 | 问题 |
|------|------|
| **实时协作编辑** | 多人同时编辑一个 Context Unit，每个字符变化都生成事件？ |
| **大批量数据导入** | 导入 10000 个角色，需要生成 10000+ 个创建事件？ |
| **早期快速迭代** | 团队还在探索产品形态，ES 复杂度是否拖慢开发速度？ |
| **简单 CRUD 场景** | 用户只是改个名字，是否需要完整的事件链？ |

**建议补充的设计：**

**1. 混合存储模式**

```yaml
StorageStrategy:
  # 核心数据：强制使用 Event Sourcing
  event_sourced:
    - ContextUnit.content
    - ContextUnit.edges
    - ContextUnit.policy
    - Agent.decisions
  
  # 辅助数据：可选简化存储
  optional_crud:
    - UserPreferences      # 用户偏好设置
    - UIState              # 界面状态
    - Cache                # 缓存数据
    - DraftBuffer          # 实时编辑缓冲区（定期合并为事件）
  
  # 批量操作：聚合事件模式
  batch_mode:
    strategy: aggregate_then_commit
    description: "批量导入时先在内存聚合，最后生成一个 BatchImportEvent"
```

**2. 实时编辑的缓冲策略**

```yaml
RealtimeEditBuffer:
  # 实时编辑不立即生成事件
  buffer_duration: 5s          # 缓冲 5 秒
  merge_strategy: last_write   # 合并为最终状态
  commit_trigger:
    - user_stops_typing: 3s    # 停止输入 3 秒后提交
    - explicit_save: true      # 用户主动保存
    - buffer_full: 100_changes # 缓冲区满
  
  # 提交时生成一个合并事件，而非 N 个字符事件
  event_type: ContentUpdated
  includes: [before_snapshot, after_snapshot, change_summary]
```

**与核心架构的关系：**

这**需要在架构设计时预留接口**，而非事后补丁。建议：
- 定义 `IStorageAdapter` 接口，ES 是默认实现
- 允许特定模块使用简化存储适配器
- 批量操作和实时编辑有专门的缓冲/聚合机制

---

#### 风险 #3: active/archived 二元生命周期

**风险评级：** 🟡 中（可扩展，但需要提前设计状态机）

**核心问题：** 二元状态假设过于简化，无法表达实际场景中的丰富生命周期需求，如草稿、待审、锁定、弃用等。

**当前设计 vs 实际需求：**

| 实际需求 | 当前设计支持 | 缺口 |
|----------|--------------|------|
| 草稿（未完成，不参与系统） | ❌ | 没有 `draft` 状态 |
| 活跃（正常参与系统） | ✅ `active` | — |
| 待审核（已提交，等待确认） | ❌ | 没有 `pending_review` 状态 |
| 锁定（临时冻结，保留引用） | ❌ | 没有 `locked` 状态 |
| 弃用（标记过时，但保留引用） | ❌ | 没有 `deprecated` 状态 |
| 归档（只读存档） | ✅ `archived` | — |

**尖锐场景：**

| 场景 | 用户需求 | 当前设计的问题 |
|------|----------|----------------|
| **草稿创作** | 「这个角色还没想好，先存着但别参与系统」 | 只能创建为 active（会触发传播）或不创建 |
| **内容审核** | 「AI 生成的内容需要人工审核后才能生效」 | 没有「待审核」状态，只能用确认队列模拟 |
| **临时冻结** | 「这个角色暂时不动，但别归档，我还要引用」 | locked 和 archived 语义不同，但只有 archived |
| **弃用标记** | 「这个设定过时了，但旧章节还在引用，不能删」 | 没有 deprecated 状态 |

**建议补充的设计：**

**1. 可扩展状态枚举**

```yaml
LifecycleStateRegistry:
  builtin_states:
    - name: draft
      description: "草稿，不参与依赖图和传播"
      participation: { dependency_graph: false, propagation: false, editable: true }
      transitions_to: [active, archived]
    
    - name: active
      description: "活跃，完全参与系统"
      participation: { dependency_graph: true, propagation: true, editable: true }
      transitions_to: [locked, deprecated, archived]
    
    - name: pending_review
      description: "待审核，可见但不触发传播"
      participation: { dependency_graph: true, propagation: false, editable: false }
      transitions_to: [active, archived]
    
    - name: locked
      description: "锁定，参与系统但不可编辑"
      participation: { dependency_graph: true, propagation: true, editable: false }
      transitions_to: [active, archived]
    
    - name: deprecated
      description: "弃用，保留引用但标记过时"
      participation: { dependency_graph: true, propagation: false, editable: false }
      ui_hint: "显示删除线，提示用户更新引用"
      transitions_to: [archived]
    
    - name: archived
      description: "归档，只读存档"
      participation: { dependency_graph: false, propagation: false, editable: false }
      transitions_to: [active]  # 可晋升
  
  extension_api:
    # 模板可定义领域特定状态
    register_state:
      name: "killed"  # 小说模板：角色死亡状态
      inherits_from: deprecated
      custom_behavior: "触发死亡相关的级联更新"
```

**2. 状态与行为映射**

| 状态 | 依赖图 | 传播 | 可编辑 | 可删除 | UI 提示 |
|------|--------|------|--------|--------|----------|
| draft | ❌ | ❌ | ✅ | ✅ | 灰色/虚线边框 |
| active | ✅ | ✅ | ✅ | ⚠️ 需确认 | 正常显示 |
| pending_review | ✅ | ❌ | ❌ | ❌ | 黄色标记 |
| locked | ✅ | ✅ | ❌ | ❌ | 锁图标 |
| deprecated | ✅ | ❌ | ❌ | ⚠️ 需确认 | 删除线 |
| archived | ❌ | ❌ | ❌ | ✅ | 归档图标 |

**与核心架构的关系：**

这**可以渐进实现**，但需要提前设计状态机接口：
- 状态存储为字符串/枚举，而非布尔值
- 状态转换规则可配置
- UI 和传播引擎通过状态属性（而非硬编码状态名）判断行为

---

#### 风险 #4: Authority Source vs Maintainer 二元权限

**风险评级：** 🟡 中（可扩展，但需要预留权限模型接口）

**核心问题：** 「谁说了算」和「谁负责维护」的二元划分在简单场景够用，但复杂团队协作场景需要更精细的权限层级和动态授权机制。

**当前设计 vs 复杂场景需求：**

| 复杂场景需求 | 当前设计支持 | 缺口 |
|--------------|--------------|------|
| 单一权威 + 单一维护者 | ✅ | — |
| 多级审批链（初审 → 复审 → 终审） | ❌ | 只有一个 Authority Source |
| 角色组继承（「编辑组」继承权限） | ❌ | 没有角色组概念 |
| 临时授权（「本周让实习生帮忙」） | ❌ | 没有时效性授权 |
| 权限委托（「我休假，授权给同事」） | ❌ | 没有委托机制 |
| 条件性权限（「只能编辑自己创建的」） | ❌ | 没有条件表达式 |

**尖锐场景：**

| 场景 | 需求 | 当前设计的问题 |
|------|------|----------------|
| **多级审批** | 重要变更需要主编 → 总编 → 主编辑三级审批 | 只有一个 Authority Source，无法表达审批链 |
| **团队协作** | 「世界观组」的所有成员都能维护世界观设定 | 没有角色组，需要逐个配置 |
| **临时授权** | 主创休假一周，临时授权给副手 | 没有时效性授权，需要手动改回 |
| **新人培训** | 新人只能编辑自己创建的角色，不能动他人的 | 没有条件性权限 |

**建议补充的设计：**

**1. 扩展权限模型**

```yaml
PermissionModel:
  # 权限层级（从高到低）
  permission_levels:
    - owner          # 完全控制，可删除、可转移所有权
    - approver       # 审批权，可批准/拒绝变更
    - maintainer     # 维护权，可提交变更建议
    - contributor    # 贡献权，可提交但需审批
    - viewer         # 查看权，只读
  
  # 单元级权限配置
  unit_permissions:
    authority_chain:        # 审批链（替代单一 Authority Source）
      - level: 1
        role: "section_editor"
        auto_approve_if: "change_size < 100_chars"
      - level: 2
        role: "chief_editor"
        required_for: "structural_changes"
    
    maintainers:            # 维护者列表（支持多个）
      - user: "agent-character-dev"
        scope: "all"
      - user: "human-author"
        scope: "manual_override"
    
    contributors:           # 贡献者
      - group: "intern_team"
        condition: "created_by_self"  # 条件性权限
```

**2. 动态授权机制**

```yaml
DynamicAuthorization:
  # 临时授权
  temporary_grants:
    - grantee: "user-bob"
      permission: maintainer
      scope: ["character-*"]      # 通配符范围
      valid_from: "2026-01-28"
      valid_until: "2026-02-04"   # 一周后自动失效
      granted_by: "user-alice"
      reason: "休假期间临时授权"
  
  # 权限委托
  delegation:
    - delegator: "user-alice"
      delegatee: "user-bob"
      permissions: [approver, maintainer]
      scope: "all_owned_units"
      can_re_delegate: false      # 不可转委托
      valid_until: "2026-02-04"
```

**3. 角色组与继承**

```yaml
RoleGroups:
  groups:
    - name: "worldbuilding_team"
      members: ["user-a", "user-b", "user-c"]
      default_permission: maintainer
      scope_pattern: "worldbuilding/*"
    
    - name: "character_team"
      members: ["user-d", "user-e"]
      default_permission: maintainer
      scope_pattern: "character/*"
  
  inheritance:
    # 子组继承父组权限
    - child: "intern_team"
      parent: "character_team"
      permission_override: contributor  # 降级为 contributor
```

**与核心架构的关系：**

这**可以渐进扩展**，但需要：
- Authority Source 从单值改为列表/链结构
- Maintainer 支持多个，带条件和范围
- 预留角色组和动态授权的数据结构

---

#### 风险 #5: ChangeSet/ImpactSet/Reason 一次性确认假设

**风险评级：** 🟡 中（用户体验核心，改动成本高但可渐进）

**核心问题：** 当前确认模型假设确认是「一次性决策」（接受或拒绝），但复杂场景需要更精细的确认流程，如分阶段、条件性、协商式确认。

**当前确认选项 vs 复杂需求：**

| 确认需求 | 当前支持 | 缺口 |
|----------|----------|------|
| 完全接受 | ✅ | — |
| 完全拒绝 | ✅ | — |
| 部分接受（「接受 A 但拒绝 B」） | ❌ | ChangeSet 是原子的 |
| 条件接受（「接受但改这个值」） | ❌ | 没有编辑后接受 |
| 延迟决策（「先放着，稍后处理」） | ❌ | 没有「稍后」状态 |
| 请求修改（「不对，请重新生成」） | ❌ | 只能拒绝，没有「重做」 |
| 协商确认（「需要 A 和 B 都同意」） | ❌ | 单人确认模型 |
| 分阶段确认（「先确认内容，再确认传播」） | ❌ | 内容和传播绑定 |

**尖锐场景：**

| 场景 | 用户需求 | 当前设计的问题 |
|------|----------|----------------|
| **部分接受** | Agent 建议改 3 处，但第 2 处不对 | 只能全部接受或全部拒绝 |
| **微调后接受** | AI 写的基本对，但有个词想改一下 | 接受后再编辑会生成新事件，溯源链断裂 |
| **暂缓处理** | 现在没空仔细看，先标记稍后处理 | 没有「暂缓」状态，确认队列会堆积 |
| **多人协商** | 这个变更涉及两个人的内容，需要两人都同意 | 只有单人确认，另一人只收到通知 |
| **分步确认** | 先确认内容没问题，但不确定要不要触发传播 | 内容确认和传播确认是绑定的 |

**建议补充的设计：**

**1. 扩展确认选项**

```yaml
ConfirmationOptions:
  # 基础选项（当前已有）
  basic:
    - accept              # 接受并传播
    - reject              # 拒绝
  
  # 扩展选项（建议新增）
  extended:
    - accept_partial:     # 部分接受
        description: "选择性接受 ChangeSet 中的部分变更"
        ui: "展示 ChangeSet 列表，每项可单独勾选"
    
    - accept_with_edit:   # 编辑后接受
        description: "接受但允许在确认时微调内容"
        ui: "打开编辑器，修改后确认"
        traceability: "记录为 AcceptWithModification 事件"
    
    - accept_no_propagate: # 接受但不传播
        description: "接受变更但暂停传播，稍后手动触发"
        ui: "确认后进入 pending_propagation 状态"
    
    - defer:              # 延迟处理
        description: "标记为稍后处理，不阻塞其他确认"
        ui: "移入 deferred 队列，可设置提醒时间"
    
    - request_revision:   # 请求修改
        description: "拒绝当前版本，请求 Agent 重新生成"
        ui: "可附加修改指导"
        triggers: "重新触发 Agent 工作流"
```

**2. 分阶段确认流程**

```yaml
StagedConfirmation:
  stages:
    - stage: content_review
      description: "审查变更内容是否正确"
      options: [accept, reject, accept_with_edit, request_revision]
      required: true
    
    - stage: impact_review
      description: "审查传播影响是否可接受"
      options: [propagate_all, propagate_selected, defer_propagation]
      required: false  # 可跳过，使用默认策略
      shows: ImpactSet 可视化
    
    - stage: final_confirm
      description: "最终确认"
      options: [confirm, cancel]
      shows: 完整变更摘要
  
  quick_mode:
    # 简单变更可跳过分阶段，直接确认
    condition: "impact_set.size < 3 AND change_size < 500_chars"
    action: "合并为单步确认"
```

**3. 多方协商确认**

```yaml
CollaborativeConfirmation:
  # 当变更涉及多个负责人时
  triggers:
    - condition: "affected_units have multiple authority_sources"
    - condition: "policy.requires_multi_party_approval"
  
  workflow:
    - collect_approvals:
        required_parties: [authority_sources of affected_units]
        approval_threshold: all | majority | any
        timeout: 48h
    
    - on_conflict:
        # 如果各方意见不一致
        options:
          - escalate_to_admin
          - use_authority_chain  # 按审批链升级
          - create_discussion    # 创建讨论线程
    
    - on_timeout:
        action: "notify_all_and_defer"
  
  ui:
    shows: "各方确认状态、意见、讨论线程"
    allows: "在确认界面直接讨论"
```

**与核心架构的关系：**

这**可以渐进实现**，核心架构改动较小：
- ChangeSet 结构支持拆分（每项变更有独立 ID）
- 确认 Event 类型扩展（AcceptPartial, AcceptWithEdit, Defer 等）
- 确认状态机扩展（支持分阶段、多方协商）
- UI 确认组件需要重构以支持新选项

---

### 维度二：用户自由度（风险 #6-7）

#### 风险 #6: 缺乏用户可定义的上层抽象

**核心问题：** 用户被迫在底层机制上手工编织，而无法在更高层次上设计模式。

**三个层面的具体表现：**

| 层面 | 用户想要 | 当前设计 | 问题 |
|------|----------|----------|------|
| **关系层** | 定义「暗恋关系」模板，自动包含语义标记、传播行为、默认规则 | Tag 管语义，Edge 管行为，两者分离 | 每次都要手动组合 |
| **类型层** | 创建「NPC 模板」，所有 NPC 自动继承字段结构和行为规则 | Context Unit 是扁平的统一抽象 | 没有模板/实例的继承机制 |
| **规则层** | 定义「角色死亡」行为包，包含状态变更、物品转移、关系解除、通知触发 | 每个规则独立配置 | 无法打包复用 |

**建议补充的设计：**

| 缺失的抽象 | 作用 |
|------------|------|
| **Relation Template（关系模板）** | 让用户定义语义+行为打包的关系类型 |
| **Unit Schema / Archetype（单元原型）** | 让 Context Unit 支持模板继承 |
| **Behavior Package（行为包）** | 让用户把一组规则打包成可复用模式 |

#### 风险 #7: 缺乏轻量级运行时控制层

**现有能力分析：**

| 能力 | 现有支持 | 局限性 |
|------|----------|--------|
| 影响预览 | ImpactSet | 静态分析，非动态模拟完整执行链 |
| 传播控制 | 安全阀（深度/频率限制） | 全局配置，非按需临时调整 |
| 隔离测试 | Branch | 需要创建、命名、管理，成本较高 |
| 状态控制 | active/archived | 二元且偏永久性，缺少「暂停」语义 |

**缺失能力与建议机制：**

| 缺失能力 | 用户场景 | 建议机制 |
|----------|----------|----------|
| 临时规则覆盖 | 「这次更新跳过传播」 | Execution Context / Session Override |
| 全局模式切换 | 「进入战争模式，切换整套规则」 | Runtime Profile / Context Mode |
| 完整模拟执行 | 「如果我改了这个，完整后果是什么」 | Dry-run Engine（内存执行，不写入） |
| 暂停状态 | 「临时冻结这个角色，但别归档」 | suspended/frozen 状态（或特殊 Tag） |
| 轻量沙盒 | 「快速试一下，不想创建正式分支」 | Lightweight Sandbox（比 Branch 更轻） |

**核心洞察：** 当用户的系统变得复杂后，他们会频繁需要低成本实验、调试、临时调整。如果每次都要创建 Branch 或修改 Policy 配置，用户会感到「操作成本太高」，进而减少实验，最终降低创造力。

---

### 维度三：产品体验（风险 #8-9）

#### 风险 #8: 上手体验与学习曲线

**风险评级：** 🔴 高风险，但可控

**当前状态：**
- ✅ 模板/配置包机制存在
- ✅ Tag + Policy 分离允许默认配置
- ✅ “系统不过时，模板可过时”的哲学为不同复杂度模板留了空间
- ❌ 没有明确的“用户成长路径”设计
- ❌ 没有“概念分层暴露”的 UI 策略
- ❌ 没有定义“第一次使用体验”应该是什么样
- ❌ 模板的定位是“配置便利”而非“上手体验核心”

**核心原则：模板不是配置便利，而是用户入口**

```
当前定位：
  系统（复杂） ← 模板（可选简化）

建议定位：
  模板（入口） → 系统（按需暴露）
```

**三层体验架构：**

| 层级 | 用户看到的 | 底层机制 | 进入条件 |
|------|------------|----------|----------|
| **L1 内容层** | 角色、章节、设定（领域语言） | Context Unit + 预设配置 | 默认 |
| **L2 协作层** | 关联、AI 建议、变更确认 | Edge + Agent + 确认机制 | 系统在合适时机引导 |
| **L3 架构层** | Context Unit、边类型、Policy | 完整抽象 | 用户主动进入“高级设置” |

**第一个“哇”时刻设计：**

```具体场景：
1. 用户选择「小说创作」模板
2. 用户创建角色「林晓」，写了简单描述
3. 用户开始写第一章，提到了林晓
4. 系统高亮提示：「检测到你提到了林晓，已自动关联」
5. 用户修改林晓的性格
6. 系统提示：「林晓的性格变了，第一章有 2 处描写可能需要调整」
7. 用户：哇！
```

**概念延迟暴露策略：**

| 概念 | 何时暴露 | 如何暴露 |
|------|----------|----------|
| 边类型 | 用户困惑“为什么有些变化传播了有些没有” | 解释不同关系的不同行为 |
| Policy | 用户想要“某些内容不需要确认” | 引导配置确认策略 |
| Snapshot/Branch | 用户想要“回到之前的版本” | 引导使用版本管理 |
| Agent 配置 | 用户想要“AI 的行为不对” | 引导调整 Agent 规则 |

**UI 双轨设计：**

| 操作 | 简单路径 | 高级路径 |
|------|----------|----------|
| 创建关联 | 在 A 的编辑界面点击“关联到 B” | 创建指定类型的 Edge |
| 设置规则 | 选择预设的“AI 行为风格” | 编辑 Policy 配置 |
| 版本管理 | 点击“保存存档点”/“回到之前” | 操作 Snapshot/Branch |

**模板复杂度分级：**

```yaml
模板分级:
  - 入门级:
      名称: "小说创作·轻松版"
      特点: 最少概念、最多自动化、适合新手
      暴露: 只有内容层
      
  - 标准级:
      名称: "小说创作·标准版"  
      特点: 平衡的概念暴露、适合有经验用户
      暴露: 内容层 + 协作层
      
  - 专业级:
      名称: "小说创作·专业版"
      特点: 完整功能、适合高级用户
      暴露: 全部三层
```

#### 风险 #9: Agent 错误级联与批量恢复

**风险等级：** 🟡 中等（有保护但操作成本高）

**当前设计的保护：**
- ✅ confirm_required 默认策略 — 错误在确认环节被拦截
- ✅ Event Sourcing + Agent 推理溯源 — 完整记录了因果链信息
- ✅ 安全阀机制 — 大规模传播会被拦截
- ✅ Snapshot — 提供时间点回溯能力

**核心缺口：**

| 缺口 | 问题 | 影响 |
|------|------|------|
| 因果链视图 | 确认队列是扁平列表 | 用户难以快速识别错误源头 |
| 因果链批量操作 | 只有时间点回滚，没有因果链回滚 | 回滚错误链时会误伤无关变更 |
| 高语义影响检测 | 安全阀只看数量，不看语义 | 「主角死亡」这类语义重大变化可能不触发预警 |
| 传播暂停选项 | 只有「接受并传播」或「拒绝」 | 缺少「接受但暂停，让我先审查」的精细控制 |

**需要补充的设计：**

**1. 确认中心升级为「因果链管理器」**
```
视图模式：
├── 时间顺序（当前）
├── 按 Context Unit 分组
└── 按触发源聚合（因果链视图）
    └── 源事件 → 一级影响 → 二级影响 → ...
```

**2. 基于因果链的批量操作**
- 「拒绝此链」— 拒绝源于同一根事件的所有待确认变更
- 「撤销此链」— 对已执行变更生成逆向事件，精确撤销
- 「隔离此链」— 移入独立分支，主线不受影响

**3. root_event_id 追踪**
```yaml
Event:
  # 现有字段
  trigger_event: 直接触发此事件的事件
  
  # 新增字段
  root_event_id: 最初触发整条链的事件
  propagation_depth: 当前是第几层传播
```

**4. 高语义影响的特殊处理**
```yaml
# 在 Policy 中定义
high_impact_patterns:
  - pattern: "角色.状态 → 死亡"
    action: require_explicit_confirmation
    pause_propagation: true
    message: "检测到重大剧情变化"
```

**5. 确认选项扩展**
```
├── ✅ 接受（并传播）
├── ❌ 拒绝
└── ⏸️ 接受但暂停传播
```

**与核心架构的关系：** 这些补充不需要改动底层架构。Event Sourcing 已经记录了足够的因果信息，缺的是基于这些信息的查询、可视化和操作能力。这是「操作层」和「体验层」的补充。

---

### 维度四：协作机制（风险 #10）

#### 风险 #10: 多人协作机制

**前置约定：三种运行模式框架**

```
├── 自动化模式：无协作需求，Agent 自主运转
└── 工作台模式
    ├── 单人工作台：基础协作层（单用户权限）
    └── 多人工作台：完整协作层
```

**Q1: 系统如何处理同时编辑冲突？**

**设计：实时感知 + 字段级乐观并发 + 冲突时自动保护**

```yaml
协作编辑模型:
  
  第一层 - 实时感知:
    # 让用户在冲突发生前就知道
    机制: 用户开始编辑时广播「正在编辑 X」
    展示: 其他用户看到 X 标记为「被 A 编辑中」
    行为: 不阻止，仅提示「A 正在编辑此内容」
    
  第二层 - 提交时冲突检测:
    # 基于 Event 的版本向量
    检测: 提交时检查目标 Unit 的版本是否已变化
    粒度: 字段级（不同字段可并行修改无冲突）
    
  第三层 - 冲突发生时的处理:
    # 不丢失任何人的工作
    步骤:
      1. 后提交者的变更保存到「待合并暂存区」（轻量，非正式分支）
      2. 通知双方用户
      3. 提供合并界面：
         - 并排展示：Base / 用户A / 用户B
         - 操作选项：保留我的 / 接受他的 / 手动合并 / 创建正式分支
      4. 合并结果作为新 Event 记录
```

**Q2: 确认队列是共享的还是各自的？**

**设计：统一数据源 + 多视图展示**

```yaml
确认队列架构:
  
  数据层:
    # 项目级统一队列
    存储: 所有待确认变更存储在同一个队列
    字段:
      - target_unit: 被变更的 Unit
      - assigned_to: 需要确认的用户（可多人）
      - triggered_by: 触发此变更的用户/事件
      - stakeholders: 相关方（需要通知但不需确认）
    
  展示层:
    # 基于用户角色过滤展示
    视图:
      「需要我确认」:
        过滤: assigned_to 包含当前用户
        特点: 这是我的待办，必须处理
        
      「影响我的内容」:
        过滤: target_unit 是我负责维护的，或我正在编辑的
        特点: 需要关注，可能需要调整我的工作
        
      「团队动态」:
        过滤: 无（显示所有）
        特点: 了解全局，可选关注
        
  分配规则:
    # 决定变更进入谁的「需要我确认」视图
    优先级:
      1. target_unit.authority_source（最高）
      2. target_unit.maintainer
      3. 项目默认审批人
```

**Q3: Agent 触发的变更建议归属于谁确认？**

**设计：职责优先 + 触发者知情**

```yaml
Agent 变更确认归属:
  
  核心原则:
    「谁负责目标 Unit，谁来确认针对它的变更」
    「触发者有知情权，但不自动获得确认权」
    
  归属决策链:
    1. target_unit 有明确 Authority Source → 该用户确认
    2. target_unit 有 Maintainer → Maintainer 确认
    3. 无明确配置 → 触发用户确认（如果有）
    4. 系统/定时触发 → 项目管理员确认
    
  典型场景:
    场景: 用户 A 修改角色，Agent 建议修改 B 负责的章节
    
    处理:
      确认归属: B（章节的 Authority/Maintainer）
      通知 A: 「你的修改触发了对第三章的建议，等待 B 确认」
      通知 B: 「A 的修改影响了你的第三章，请确认建议的更新」
```

**Q4: 如果用户 A 的修改被用户 B 拒绝，通知机制是什么？**

**设计：分层通知 + 闭环反馈**

```yaml
通知系统:
  
  通知分类:
    必达通知（高优先级）:
      - 你的变更被他人拒绝
      - 有人请求你确认变更
      - 检测到编辑冲突
      - 你负责的内容被他人修改
      
    关注通知（可配置）:
      - 你触发的变更被接受
      - 你关注的 Unit 有更新
      - 团队里程碑事件
      
  拒绝场景的完整流程:
    
    当 B 拒绝 A 触发的建议:
      
      通知给 A:
        标题: 「你触发的变更建议被拒绝」
        内容:
          原始操作: 你对「角色林晓」的修改（链接）
          触发的建议: Agent 建议更新「第三章」
          拒绝者: 用户 B
          拒绝理由: [B 填写的理由，如有]
        后续选项:
          - 查看详情
          - 向 B 发起讨论
          - 查看林晓当前状态
          - 查看第三章当前状态
          
      Event 记录:
        # 完整溯源
        action: change_rejected
        actor: B
        target: 第三章
        root_trigger: A 对林晓的修改
        reason: [B 的拒绝理由]
        
  通知渠道:
    默认: 应用内通知中心
    可配置: 邮件通知（重要事件）
    企业版: Webhook 集成（推送到 Slack/飞书等）
```

**权限模型：**
- owner: 完全控制权
- maintainer: 日常维护权
- contributor: 可提交变更，需审批
- viewer: 只读

**协作层与运行模式的关系：**

```yaml
运行模式与协作层:
  
  自动化模式:
    协作层: 最小化
    特点: 无实时编辑冲突、无人工确认队列
    需要: 结果输出的订阅通知
    
  单人工作台:
    协作层: 基础
    特点: 无冲突处理、简化确认队列
    需要: 单用户权限模型
    
  多人工作台:
    协作层: 完整
    特点: 冲突处理、分层确认、跨用户通知、角色权限
    需要: 本设计的全部内容
    
  实现策略:
    # 底层数据模型从一开始就支持多用户
    Event.actor_user_id: 必须字段
    ContextUnit.authority_source: 必须字段
    ContextUnit.maintainer: 必须字段
    
    # 协作层作为可选模块加载
    单人模式: 简化 UI，不加载冲突处理等
    多人模式: 加载完整协作层
```

**核心原则：**
> 底层数据模型从第一天就支持多用户，协作 UI 可渐进增强。
> 不丢失任何人的工作，冲突时保护而非覆盖。
> 谁负责谁确认，触发者有知情权无越权。

---

### 项目框架补充：三种运行模式

用户补充了项目的整体运行模式框架：

```
项目运行模式:

├── 自动化模式
│   特点: 无人工干涉，全程自动化运行
│   场景: AI Agent 有机体持续运转，源源不断提供服务
│   类比: 更像一个「活着的有机体」
│
└── 工作台模式
    特点: 中间环节有人工介入，人机协作产出成果
    
    ├── 单人工作台
    │   场景: 个人创作者、独立开发者
    │   协作层: 基础（单用户权限）
    │
    └── 多人工作台
        场景: 团队协作、多部门共同维护
        协作层: 完整（冲突处理、权限管理、通知机制）
```

> **统一性原则澄清（后续 Product Brief 中进一步明确）：**
> 
> **不存在"三套系统"，只有"一套系统的三种配置"。**
> 
> 三种运行模式共享同一套底层机制（Context Unit、四类边、传播引擎、Event Sourcing、Agent 执行、确认机制、版本管理），真正的区别只有两个维度：
> 1. **触发条件配置**：手动触发 vs 协作事件 vs 定时/外部调用
> 2. **确认/审核策略**：单用户确认 vs 多方审批 vs 自动确认
> 
> 这意味着大部分技术可以复用，无需为每种模式重新设计，只需针对每种模式做少量定制化配置。

---

### 待设计领域

**待设计 #1: 开放生态 / 外部连接能力**

用户明确表示一定是「开放生态」，支持：
- 用户可以把 Context Unit 连接到外部数据源（API、数据库、文件）
- 用户可以让外部工具订阅系统事件
- 用户可以导出/导入部分系统状态到其他工具

**状态：** 明确意图，待具体设计（如 Webhook、API schema、数据格式等）

---

**待设计 #2: 生态兼容（MCP/Skills）**

> **确认（2026-01-29 Product Brief 阶段）：** MAV 必须完整实现生态兼容能力：

| 能力 | MAV 状态 | 说明 |
|------|----------|------|
| MCP 工具兼容 | ✅ 完整实现 | 利用大模型已有工具调用训练数据 |
| Skills 设计范式 | ✅ 完整实现 | 深度融入系统 Agent 设计 |
| 外部连接基础 | ✅ 基础版 | Webhook、基础 API |

**策略意图：** 让 Agent 在系统中「如鱼得水」，降低用户学习成本。

---

## Phase 4: 想法组织与行动规划

**日期：** 2026-01-28

### 主题识别与聚类

通过系统性分析，将所有设计决策和风险组织为 **8 个核心主题**：

| 主题 | 内容概要 | 关联风险 |
|------|----------|----------|
| 主题 1: 核心抽象与数据模型 | Context Unit、四类边、Tag+Policy、权限模型 | #1, #3, #4 |
| 主题 2: 事件溯源与传播系统 | Event Sourcing、Agent 推理溯源、触发机制 | #2 |
| 主题 3: 版本管理与时间旅行 | Snapshot、Branch、Query Scope、两阶段回溯重构 | - |
| 主题 4: 用户体验与认知设计 | 三层体验架构、概念延迟暴露、UI 约束选择 | #8 |
| 主题 5: 用户自由度与扩展机制 | 上层抽象、运行时控制、注册机制 | #6, #7 |
| 主题 6: 确认与协作机制 | 确认扩展、因果链管理、多人协作 | #5, #9, #10 |
| 主题 7: 架构与性能 | 全量存储+按需激活、Rust+TypeScript 分层 | - |
| 主题 8: 项目框架与方法论 | 双重交付、设计锚点、三种运行模式 | - |

---

### 版本定位：MAV（最小惊艳版本）

**核心理念：** 不是 MVP（最小可行），而是 MAV（Minimum Awesome Version，最小惊艳版本）

**MAV 定义标准：**
- 用户在 10 分钟内体验到“哇”时刻
- 核心价值主张（“让 AI 有状态”）被清晰感知
- 小说创作场景完整可用，不是 demo
- 用户愿意持续使用、付费、推荐

---

### MAV 范围定义

#### 运行模式（功能+UI一体交付）

> **更新（2026-01-29 Product Brief 阶段澄清）：** 遵循「功能+UI 一体交付」原则，三种运行模式均需在 MAV 中提供基础功能和配套 UI，不存在「UI 后置」。

| 模式 | MAV 范围 | V1.5+ 扩展 |
|------|----------|------------|
| 单人工作台 | ✅ 完整功能 + 完整UI | — |
| 多人工作台 | ✅ 基础协作功能 + 基础协作UI（权限配置、变更通知、简化审批） | 复杂冲突处理UI、多级审批流程UI |
| 自动化模式 | ✅ 配置功能 + 配置UI（触发条件、自动确认策略、基础监控） | 专业运维仪表盘、高级监控分析UI |

#### 核心抽象

| 概念 | MAV 状态 | 说明 |
|------|----------|------|
| Context Unit | ✅ 完整实现 | 统一抽象，支持任意嵌套 |
| 四种边类型 | ✅ 完整实现 | Reference/Activation/Containment/Derivation |
| Tag + Policy | ✅ 完整实现 | 分类与行为正交 |
| 生命周期状态 | ✅ active/archived/draft | 预留状态注册接口 |
| Authority/Maintainer | ✅ 基础实现 | 预留扩展权限接口 |

#### 事件与溯源

| 能力 | MAV 状态 | 说明 |
|------|----------|------|
| Event Sourcing | ✅ 完整实现 | 系统灵魂 |
| Agent 推理溯源 | ✅ 基础实现 | 记录 reasoning、inputs_read |
| ChangeSet/ImpactSet/Reason | ✅ 完整实现 | 确认机制核心 |
| 因果链可视化 | 🟡 基础版 | 完整版 V1.5 |

#### 版本管理

| 能力 | MAV 状态 | 说明 |
|------|----------|------|
| Snapshot | ✅ 用户可操作的命名快照 | 核心能力 |
| Branch | 🟡 基础分支（创建、切换） | 合并/冲突解决 V1.5 |
| Query Scope | 🟡 基础（当前/指定快照） | 跨分支查询 V1.5 |
| 两阶段回溯重构 | ❌ 后置 | V2.0 |

#### 确认机制

| 能力 | MAV 状态 | 说明 |
|------|----------|------|
| 基础确认（accept/reject） | ✅ | 必须 |
| 部分接受 | ✅ | 核心体验 |
| 编辑后接受 | ✅ | 核心体验 |
| 延迟处理（defer） | ✅ | 实用功能 |
| 四种确认模式 | ✅ | 严格/宽松/批量/YOLO |
| 分阶段确认 | 🟡 简化版 | 完整版 V1.5 |
| 多方协商确认 | ❌ | 多人模式 V2.0 |

#### 用户体验

| 能力 | MAV 状态 | 说明 |
|------|----------|------|
| 三层体验架构 | ✅ 完整实现 | 生死线 |
| 概念延迟暴露 | ✅ 完整实现 | 生死线 |
| UI 约束选择模式 | ✅ 完整实现 | 杠绝无效输入 |
| 有机系统蓝图视图 | ✅ 完整实现 | 核心差异化 |

---

### 概念最小集

用户必须理解的最小概念集合：

| 用户看到的术语 | 底层对应 | 说明 |
|----------------|----------|------|
| **内容块** | Context Unit | 你创作的任何内容单元 |
| **关联** | Edge | 内容块之间的联系 |
| **AI 助手** | Agent | 帮你维护内容的智能伙伴 |
| **变更提醒** | ChangeSet + ImpactSet | AI 发现需要调整的地方 |
| **确认** | Confirmation | 你决定是否接受 AI 的建议 |

其他所有概念（边类型、Policy、Event Sourcing 等）在 L1 层对用户隐藏，只在用户进入 L2/L3 时逐步暴露。

---

### “活”的具体表现（MAV 必须实现）

| # | 用户行为 | AI 的“活”表现 | 优先级 |
|---|----------|---------------|--------|
| 1 | 创建角色 | 自动识别为“角色”类型，建立初始结构 | ✅ MAV |
| 2 | 写章节提到角色 | 自动识别引用，建立 Reference Edge | ✅ MAV |
| 3 | 修改角色设定 | 主动提示：“第 X、Y、Z 章提到这个角色，可能需要调整” | ✅ MAV |
| 4 | 写了新章节 | 自动提取新出现的实体，问用户要不要纳入系统 | ✅ MAV |
| 5 | AI 发现设定矛盾 | 主动提醒（基于规则检测） | 🟡 V1.5 |
| 6 | 用户一段时间没写 | 基于大纲给续写建议 | ❌ V2.0 |

---

### 小说创作模板设计

#### 预设 Context Unit 类型

| 类型 | Tag | 典型字段 | 说明 |
|------|-----|----------|------|
| 角色 | #角色 | 姓名、外貌、性格、背景、关系 | 核心 |
| 势力 | #势力 | 名称、立场、成员、资源 | 包含角色 |
| 地点 | #地点 | 名称、描述、位置关系 | 场景背景 |
| 物品 | #物品 | 名称、属性、持有者 | 重要道具 |
| 事件 | #事件 | 时间、参与者、结果 | 情节节点 |
| 大纲 | #大纲 | 章节结构、情节线 | 创作指导 |
| 章节 | #章节 | 标题、正文、关联设定 | 最终产出 |
| 设定 | #设定 | 世界观、规则、背景 | 基础约束 |

#### 预设边关系

| 关系 | 边类型 | 示例 | 传播行为 |
|------|--------|------|----------|
| 引用 | Reference | 章节引用角色 | 触发下游重新评估 |
| 从属 | Containment | 角色属于势力 | 向上冒泡脏标记 |
| 触发 | Activation | 角色死亡 → 更新关系网 | 触发 Maintainer 工作 |
| 派生 | Derivation | 章节派生自大纲 | 仅记录来源 |

#### 预设 Agent

| Agent | 职责 | 默认模型 |
|-------|------|----------|
| 引用识别 Agent | 分析章节内容，识别对设定的引用 | 快速模型 |
| 一致性检查 Agent | 检查章节与设定是否矛盾 | 推理模型 |
| 关系维护 Agent | 当角色关系变化时更新关系网 | 中等模型 |
| 摘要 Agent | 为章节生成摘要 | 快速模型 |

---

### 技术架构

```
┌─────────────────────────────────────┐
│       TypeScript 层（前端）          │
│   (UI, 交互逻辑, 状态管理)           │
└──────────────┬──────────────────────┘
               │ API / WebSocket
┌──────────────▼──────────────────────┐
│          Rust 层（后端）             │
│   (Event Store, 查询引擎,           │
│    状态投影, Agent 调度,            │
│    传播引擎, LLM 调用)              │
└─────────────────────────────────────┘
```

**Rust 负责：** Event Sourcing 存储与查询、状态投影与快照、依赖图与传播计算、Agent 调度与 LLM 调用、性能关键路径

**TypeScript 负责：** 全部 UI/UX、前端状态管理、用户交互逻辑

---

### 下一步行动计划

| 顺序 | 行动 | 负责 | 产出 |
|------|------|------|------|
| 1 | 核心抽象与接口设计 | 架构团队 | 架构设计文档 |
| 2 | UX/UI 设计 | 设计团队 | 完整设计稿 |
| 3 | 小说模板详细设计 | 产品团队 | 模板配置文档 |
| 4 | 技术选型验证 | 开发团队 | Rust+TS 技术 spike |
| 5 | 可交互原型开发 | 全团队 | 能跑通核心流程的原型 |

**1-3 可以并行进行，4-5 依赖前三项。**

---

### 验证目标

核心验证目标：**完整的 UX/UI 设计，能跑通小说创作场景**

具体验证流程：
1. 创建角色 → 系统识别
2. 写章节 → 自动关联
3. 改设定 → 提示影响
4. 用户确认 → 状态更新
5. 创建快照 → 版本保存

---

## 会话总结

### 创意成就

- **15 个核心设计决策**（Phase 1 - 第一性原理思考）
- **10 个关键风险及解决方案**（Phase 2 - 失败分析）
- **8 个组织化主题**（Phase 4 - 想法组织）
- **MAV（最小惊艳版本）完整定义**
- **5 个明确的下一步行动**

### 关键突破

- 明确了 MAV vs MVP 的定位（追求惊艳而非仅可行）
- 定义了“概念最小集”（5 个用户必须理解的核心概念）
- 具象化了“活”的具体表现（4 个 MAV 必须实现的 AI 行为）
- 确定了小说模板的完整预设（8 种 Unit 类型、4 种边关系、4 个 Agent）
- 制定了技术架构（Rust 后端 + TypeScript 前端）

### 会话价值

本次头脑风暴将《总体想法.md》从初步构想升级为可执行的系统设计蓝图，明确了：
- 核心抽象与接口设计方向
- MAV 的具体范围和验收标准
- 用户体验的核心策略
- 下一阶段的具体行动计划

---

**会话完成时间：** 2026-01-28
**引导者：** 耶稣
**技术执行状态：** 完成

