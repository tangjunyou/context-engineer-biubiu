---
stepsCompleted: [1]
inputDocuments: ['总体想法.md']
session_topic: '通用 AI 上下文工程系统设计完善与风险识别'
session_goals: '将构想从想法稿升级为可执行的系统设计蓝图'
selected_approach: 'progressive-flow'
techniques_used: ['First Principles Thinking', 'Morphological Analysis', 'Six Thinking Hats', 'Constraint Mapping']
ideas_generated: []
context_file: '总体想法.md'
---

# Brainstorming Session Results

**Facilitator:** 耶稣
**Date:** 2026-01-22

## Session Overview

**Topic:** 通用 AI 上下文工程系统（工作台）——设计完善与风险识别
**Goals:** 验证核心概念、收敛开放问题、发现潜在盲点、优化系统架构

### Context Guidance

输入文档`/Users/jingshun/Desktop/AI 上下文工程可视化项目/总体想法.md`描述了一个通用 AI 上下文工程系统的完整构想，包括：
- 核心抽象：上下文单元（变量 + 卡片）
- Agent 分层职责（系统级/变量级/审查级）
- 变更传播与溯源系统
- 微内核+插件化底层架构
- 6个待讨论的开放问题

### Session Setup

用户希望通过系统化的头脑风暴将这个初步构想梳理成熟，使项目变得更加健壮和可落地。

---

## Phase 1: 发散探索（First Principles Thinking）

### 摘要
本次头脑风暴以第一性原理审视原始设计，形成了 **15 个核心设计决策**：
1) 统一"变量/卡片"为 Context Unit；
2) 引入 active/archived 生命周期与"晋升"机制；
3) 区分 Reference/Activation/Containment/Derivation 四类关系边；
4) Tag + Policy 分离（分类与行为正交）；
5) Authority Source vs Maintainer 分离；
6) Trigger = Event + Condition + 安全阀；
7) ChangeSet/ImpactSet/Reason 结构化确认；
8) Event Sourcing 作为溯源底座；
9) 配置包版本化 + Migration；
10) UI 范式：有机系统蓝图 + 让 AI "活"起来的核心愿景；
11) Agent 推理溯源 + 双视图权限配置；
12) Snapshot 用户化（命名快照 + 多种创建方式）；
13) Branch 分支管理（冲突解决 + 两阶段回溯重构）；
14) Query Scope + UI 约束选择模式；
15) 性能架构：全量存储 + 按需激活（Rust + TypeScript）。

---

## 背景：我们在挑战什么？
输入文档《总体想法.md》描述了一个通用 AI 上下文工程系统的初步构想。核心理念是：**LLM 本质无状态，要让 AI 在复杂长期任务中表现得“有状态、连贯、可控”，关键在于上下文工程。**
原始设计包含：变量/卡片、溯源系统、变量结果/卡片结果、四种确认模式等。我们用第一性原理挑战它们：是否存在更简洁且可扩展的抽象？

---

## 问题 1：变量和卡片真的是两个不同的东西吗？

### 问题背景
原始设计用“变量=原子”、“卡片=组合”的二元抽象。

### 挑战
> 「角色卡」能被「势力卡」引用为“变量”吗？若可以，二者的区分是否只是视角而非本质？

### 讨论
用户确认可以，并指出“变量们其实都是上下文包”。由此可见二者本质一致，只是粒度不同。

### 结论
**统一抽象：Context Unit（上下文单元）**
- 底层只有一种实体，可作为叶子或容器；
- “变量/卡片”留在 UI 作为视图/标签，而非底层结构。

**价值**：存储、权限、溯源、传播、查询、UI 复用同一机制，显著降复杂度。

---

## 问题 2：「变量」与「变量结果」的边界是什么？

### 问题背景
区分“变量=活数据”与“变量结果=固定产出”在实践易模糊。

### 挑战
> AI 写第三章正文引入新角色。应当：A) 仅留在结果；B) 自动提取为变量；C) 由用户决定是否提升？

### 讨论
- 否决 A：信息被锁在结果中，难以复用；
- 否决 B：自动膨胀，变量爆炸；
- 选择 C：保留人类最终决策权，按需纳入系统。

### 结论
**生命周期：active / archived + 晋升机制**
- `active`：参与依赖图、会触发传播、可修改；
- `archived`：只读存档、不触发传播、不入依赖网；
- **默认原则：AI 产出中新出现的实体/事实默认进入 `archived`，仅在确认后才可晋升为 `active`。**
- 支持 `archived → active`“晋升”，必须经确认并记录溯源。

**价值**：避免膨胀（默认不进系统网络）、保留决策权、不丢信息、过程可追溯。

---

## 问题 3：引用即依赖，但所有关系都是同一种“边”吗？

### 问题背景
原始设计把所有关系都视作“引用边”，易导致传播混乱与可视化负担。

### 挑战
> “包含关系”和“被规则引用”是同一种吗？“触发维护”和“派生来源”又是同一种吗？

### 讨论
不同关系语义与传播行为不同，需要区分与可视化过滤。

### 结论
**四种边类型**
| 边类型 | 语义 | 传播行为 | 示例 |
|---|---|---|---|
| Reference | 规则/Prompt 中引用 | ✅ 触发下游重新评估 | `{{角色A}}` 被写作规则引用 |
| Activation | A 变化激活 B 维护流程 | ✅ 触发 Maintainer 工作 | 角色死亡 → 激活相关状态更新 |
| Containment | 结构包含（父子） | ⚠️ 仅向上冒泡状态变化（脏标记），不向下游传播；是否进一步触发维护需显式规则 | 角色卡包含“姓名/性格” |
| Derivation | 派生/溯源 | ❌ 仅记录来源，不参与传播 | 第三章正文派生自角色卡+大纲 |

**价值**：UI 可按边类型过滤，传播规则清晰，契合“神经系统”隐喻。

---

## 问题 4：类型体系（CONST/SLOW/DYN）在统一抽象下怎么办？

### 问题背景
原始设计延续了传统变量类型分类：CONST（常量）、SLOW（缓慢变化）、DYN（动态）、FACT（事实）。这种分类体系假设变量有固定的“本质类型”。

### 挑战
> 如果一切都是 Context Unit，固定的四分类还有意义吗？一个变量能不能既是“人物相关”又是“高风险需审查”？

### 讨论
- 固定分类的问题：一个变量只能属于一种类型，但实际场景中往往需要多维度描述；
- 用户反馈：应该通过“标题、备注和 #标签”来分类，而非强制类型；
- 进一步区分：分类（是什么）和行为（怎么对待）是两件事，不应耦合。

### 结论
**Tag + Policy 分离**
- Tag 管“是什么”（如 `#人物` `#世界观` `#关键事实` `#不可变`）；
- Policy 管“怎么对待”（确认模式、可写 Agent、可用模型等）。

**Policy 结构示例：**
```yaml
Policy:
  confirmation_strategy: confirm_required  # immediate / confirm_required / batch_queue / auto_trusted
  allowed_maintainers: [Agent-A, Agent-B]
  allowed_models: [claude-3, gpt-4]
  requires_review: true
  max_auto_propagation_depth: 3
```

**价值**：分类与行为正交，最大灵活与可迁移性。

---

## 问题 5：`owner` 概念如何在通用系统中定义？

### 问题背景
原始设计《总体想法.md》第 11 节将 `owner` 概念列为开放问题：「在通用系统里是否应该下沉到模板？或者区分“权威源”与“维护权”」。

### 挑战
> 一个 Context Unit 的 owner 是指“谁有权修改它”还是“最终以谁的版本为准”？如果 AI Agent 提出修改建议，但人类是最终权威，如何表达这种关系？

### 讨论
- “owner”一词含义模糊：可能指创建者、维护者、或权威来源；
- 实际场景：一个角色设定可以是“人类为最终权威”+“AI Agent 负责监控和建议修改”；
- 需要分离两个概念：谁说了算（冲突时）vs 谁负责日常维护。

### 结论
**Authority Source vs Maintainer 分离**
- Authority Source：冲突时以谁为准（人类/外部文档/系统/Agent）；
- Maintainer：谁负责提更新建议（Agent/人类/规则）。

**价值**：消除歧义，权限/职责更精确。

---

## 问题 6：触发机制够不够？条件/批量/链式爆炸如何处理？

### 问题背景
原始设计列出四种触发类型：用户输入、关联变量变更、定时触发、外部调用。这些是否足够覆盖实际场景？

### 挑战
> 1. 条件触发怎么办？比如“当章节数 > 10 时自动触发某流程”。
> 2. 批量触发怎么办？用户选中一组变量统一更新。
> 3. 链式爆炸怎么办？A→B→C→D 形成长链时，如何防止无限传播？

### 讨论
- 四种触发本质是**事件源**，不是触发机制本身；
- 条件触发 = 事件源 + 条件过滤，不需要新增“第五种触发”；
- 批量触发 = 多个事件的聚合处理，应在确认中心支持；
- 链式爆炸需要系统级安全阀，而非依赖用户配置。

### 结论
**Trigger = Event + Condition + 安全阀**
- 事件源：user_input / unit_changed / time_tick / external_call / 自定义；
- 条件：可选的过滤规则，满足时才触发；
- 安全阀：最大传播深度、频率限制/去抖、`impactSet` 超阈强制人工确认。

**价值**：可扩展（不用加新触发类型）、不易过时、安全可控。

---

## 问题 7：确认机制如何结构化？

### 问题背景
原始设计提出四种确认模式：严格、宽松、批量接受、YOLO。这是正确方向，但“确认”的数据结构是什么？

### 挑战
> 用户在确认时需要知道什么？只是“接受/拒绝”吗？还是需要看到完整的变更上下文？

### 讨论
- 如果只是“是/否”开关，用户无法做出明智决策；
- 用户需要知道：要改什么（ChangeSet）、会影响谁（ImpactSet）、为什么要改（Reason）；
- 四种模式本质是“谁可以自动提交 ChangeSet”和“什么情况必须人工介入”的策略配置。

### 结论
**ChangeSet + ImpactSet + Reason**
- ChangeSet：要改哪些单元、改成什么（可拆分接受）；
- ImpactSet：会影响哪些下游（按层级/边类型计算）；
- Reason：为何而改（触发事件 trigger、证据引用 evidence refs、可选 agent rationale）。
- 执行策略：immediate / confirm_required（默认）/ batch_queue / auto_trusted。

**价值**：让确认基于完整上下文，不是“是/否”开关；策略可按 Tag/Policy 精细配置。

---

## 问题 8：溯源系统应当是模块还是地基？

### 问题背景
原始设计将溯源称为“系统灵魂”，并列为十大模块之一。但这种定位是否足够？

### 挑战
> 如果溯源只是“模块之一”，它就可能被绕过或事后补充。如何让“强制溯源”成为架构必然而非约定？

### 讨论
- 溯源不应是“事后记录”，而应是“系统事实的定义方式”；
- Event Sourcing 架构：当前状态 = 所有事件的折叠结果；
- 这样溯源不是可选功能，而是数据存储的本质——无法绕过。

### 结论
**Event Sourcing 作为溯源底座**
- Event Store：不可变事件记录（谁在何时因何对哪些单元做了什么）；
- Projection：当前状态视图（由事件计算得出）；
- Snapshot：性能优化的状态快照；
- 统一 Query API：UI 和 Agent 共用同一套查询接口。

**价值**：强制溯源（架构必然）、时间旅行、Undo/Redo、Diff 对比、统一查询模型。

---

## 问题 9：模板/配置包会过时，如何安全升级？

### 问题背景
核心哲学是“系统不过时，模板可过时”。但如果官方小说模板升级了 schema，用户项目怎么办？

### 挑战
> 一年后你升级官方模板，用户的旧项目能否平滑迁移？如果不能，核心愿景就会被破坏。

### 讨论
- 没有 migration 机制，模板升级会导致用户项目崩溃；
- 这不是“以后再考虑”的问题，必须从第一天设计；
- 配置包需要版本号 + 迁移规则。

### 结论
**版本化 + Migration**
- 配置包声明 `schemaVersion`；
- 提供从旧版本的迁移脚本/规则（哪怕初期很简单）；
- 系统在加载配置包时检测版本，自动或提示运行迁移。

**价值**：兑现“系统不过时，模板可过时”的核心承诺；用户项目可安全升级。

---

## 问题 10：与 Dify 的本质区别是什么？（范式转换）

### 范式对比
| 维度 | Dify 范式 | 本项目范式 |
|---|---|---|
| 构建思维 | 流程图：A→B→C | 有机系统：设计器官与相互作用 |
| 核心问题 | 下一步做什么 | 系统需要哪些器官，如何协同 |
| 执行模型 | 顺序/并行 | 事件驱动 + 相互响应 |
| 变更模型 | 手动触发下一步 | 变更沿“神经系统”传播 |

### 结论（UI 必须体现）
- 主视图="系统蓝图"，卡片="器官"，连线="神经/血管"，溯源="神经系统扫描"；
- 构建起点是"需要哪些器官"，而非"第一步做什么"。

### 深层愿景：让 AI "活"起来

本项目的最高目标不只是"更好的工作流编排"，而是构建**可以自主运转的 AI 有机体**：

| 层面 | Dify 等工作流平台 | 本项目（上下文工程平台） |
|------|-------------------|---------------------------|
| 产品定义 | 工作流是产品 | 有机体是产品，工作流只是运行模式之一 |
| 运行方式 | 被动执行（等待触发） | 持续"活着"（响应、协调、自主运转） |
| 状态来源 | 状态存在于流程节点之间 | 状态内化于有机体本身 |
| 核心洞察 | 编排执行顺序 | **上下文工程赋予 AI 状态** |

**关键理念：**
> AI 本质无状态。是精密的上下文工程设计让 AI 有了状态——让 AI Agent 真正"活"了起来。

**设计影响：**
- UI/UX 必须引导用户用"设计有机体"而非"编排流程"的思维
- 系统可以运行在两种模式：
  - **协作模式**：人机协同，按需触发，产出结果（如小说创作）
  - **自主模式**：有机体持续自主运转，响应环境变化

---

## Phase 1 总结：15 个核心设计决策

| # | 决策 | 核心理由 |
|---|---|---|
| 1 | 统一为 Context Unit | 降复杂、机制复用 |
| 2 | active/archived + 晋升 | 避免膨胀、保决策权、可追溯 |
| 3 | 四类边（Reference/Activation/Containment/Derivation） | 传播清晰、可视化友好 |
| 4 | Tag + Policy | 分类/行为正交、可迁移 |
| 5 | Authority vs Maintainer | 权限与职责精确化 |
| 6 | Event + Condition + 安全阀 | 可扩展与安全控制 |
| 7 | ChangeSet/ImpactSet/Reason | 基于完整信息的确认 |
| 8 | Event Sourcing | 溯源为地基、时间旅行 |
| 9 | 包版本化 + Migration | 模板安全升级 |
| 10 | UI 范式 + 核心愿景 | 让 AI "活"起来，有机体思维 |
| 11 | Agent 推理溯源 + 双视图权限 | 底层记录一切、灵活配置入口 |
| 12 | Snapshot 用户化 | 版本管理、可回溯、可命名 |
| 13 | Branch + 冲突解决 + 两阶段重构 | 安全分支、可控重构 |
| 14 | Query Scope + UI 约束选择 | 灵活引用、杜绝无效输入 |
| 15 | 全量存储 + 按需激活 | 历史完整、查询高效 |

---

## 待议事项（后续 Phase 讨论）

**✅ 已解决：术语冲突**
- 原“Trigger 边”已改名为 **Activation Edge**（表示“A 变化激活 B 维护流程”的关系）
- **Trigger Rule**：Event + Condition + 安全阀（规则配置对象）
- 两者现已明确区分

**✅ 已补充：Containment 边的向下广播规则**

**ContainmentEdge 的可选配置：**
```
├── bubbleUp: true（默认）——子级变化向上冒泡脏标记
├── broadcastDown: false（默认）——父级变化不自动向下广播
└── broadcastRules: [可选] 定义哪些父级属性变化时广播给哪些子级
```

**配置示例：**
```yaml
# 势力卡的 Containment Policy
containment:
  broadcastRules:
    - when: "阵营立场" changed
      notify: all children with tag #角色
      action: suggest_review  # 建议审查，而非强制更新
```

**设计原则：**
- 默认行为简单（不广播），降低认知负担
- 高级用户可配置复杂规则
- 广播动作默认为 `suggest_review`（建议审查），而非 `force_update`（强制更新），保留人类决策权

---

## 问题 11：Agent 推理过程如何纳入溯源？

### 问题背景
每个变量/卡片可以绑定 AI Agent 负责。当 Agent-A 更新变量 X 后，关联变量的 Agent-B 会收到通知。Agent-B 可能需要查询“Agent-A 为什么更新 X”来做出更准确的判断。

### 挑战
> 溯源系统是否需要记录 Agent 的完整推理过程？Agent 对溯源系统的查询本身是否也要记录？

### 讨论
- 底层设计理念：**底层记录一切，用户层选择性开放**
- Agent 的完整推理过程（Chain of Thought）应该记录
- Agent 的溯源查询行为本身也应该记录
- 这符合核心理念：高度模块化底层 + 高度用户自定义 = 立于不败之地

### 结论
**Event 结构扩展：**
```yaml
Event:
  # 基础信息
  timestamp, actor, action, subject, changes
  
  # Agent 推理上下文（新增）
  reasoning:
    trigger_event: 触发此次更新的事件
    inputs_read: Agent 读取了哪些 Context Unit
    traceability_queries: Agent 做了哪些溯源查询
    chain_of_thought: Agent 完整推理过程
    conclusion: 最终结论
  
  # 传播信息（新增）
  notifications_sent: 通知了哪些下游 Agent
```

**Agent 溯源查询 API：**
| 查询 | 权限级别 |
|------|----------|
| `getLatestChange(X)` | 基础 |
| `getChangeTrigger(X)` | 标准 |
| `getAgentRationale(X)` | 高级 |
| `getInputsConsidered(X)` | 高级 |
| `traceBack(X, depth)` | 完整 |

**关键原则：**
- 底层 Event Store 记录一切（推理过程、查询行为、通知记录）
- 用户可配置每个 Agent 的查询权限级别
- 用户可在 Agent 规则（Prompt）中指定何时调用溯源查询

**权限配置的双视图同步：**

用户可以从两个视图配置 Agent 权限，底层数据同步：

| 视图 | 入口 | 配置角度 |
|------|------|----------|
| Context Unit 编辑视图 | 编辑变量/卡片时 | 「这个单元允许哪些 Agent 访问」 |
| Agent 管理视图 | Agent 总管理界面 | 「这个 Agent 可以访问哪些单元」 |

**同步原则：**
- 底层是单一数据源
- 任一视图的修改实时反映到另一视图
- 用户按习惯选择入口，无需记忆「正确的配置位置」

**价值：**Agent 间协作有据可查、可追溯、可调试；用户可按需控制复杂度。

---

## 问题 12：如何支持项目级的版本管理与回溯？

### 问题背景
复杂项目（如长篇小说、大型软件项目、法律案件等）需要在不同阶段保存进度，并能回溯到历史状态。Event Sourcing 提供了事件级的历史记录，但用户需要更高层次的「项目快照」能力。

### 挑战
> 用户需要：1) 定期保存项目完整状态；2) 回溯到某个历史节点；3) 从历史节点分叉继续工作而不丢失原进度。

### 讨论
- Event Sourcing 已有 Snapshot 概念（用于性能优化），但不是用户可操作的；
- 用户需要的是「命名的、可管理的」快照，类似 Git 的 commit；
- 回溯后的操作需要支持多种模式：查看、继续、重构。

### 结论
**Snapshot 升级为用户可操作的版本管理能力**

```yaml
Snapshot:
  id: "snapshot-uuid"
  name: "第49章定稿"          # 用户命名
  created_at: timestamp
  created_by: user | system | schedule
  branch: "main"
  description: "完成第49章，角色关系稳定"  # 可选备注

  # 创建方式
  triggers:
    - manual: 用户手动创建
    - scheduled: 定时自动创建（如每小时/每天）
    - event: 特定事件触发（如「章节标记为完成」）
```

**用户操作：**
| 操作 | 说明 |
|------|------|
| 创建快照 | 保存当前项目完整状态 |
| 查看快照 | 只读浏览历史状态 |
| 回溯到快照 | 将项目状态恢复到该快照（详见问题 13 的分支处理） |
| 对比快照 | Diff 两个快照之间的变化 |

**价值**：项目级版本管理、安全回溯、进度可视化。

---

## 问题 13：回溯后如何处理？（分支管理）

### 问题背景
当用户回溯到历史快照后，有多种可能的后续操作。需要支持 Git 式的分支管理。

### 挑战
> 用户回溯到「第30章定稿」后，可能想：A) 查看当时状态；B) 从此处分叉继续，保留原进度；C) 回滚并删除后续进度；D) 修改后触发全链路重构。

### 讨论
- 简单的「撤销/重做」不够，需要分支概念；
- 分支允许实验性修改而不影响主线；
- 「回溯重构」是特殊场景：修改历史节点后，所有相关变量需要重新评估。

### 结论
**Branch（分支）作为平台能力**

```yaml
Branch:
  id: "branch-uuid"
  name: "主线" | "第30章重写实验"
  parent_snapshot: "snapshot-xxx"  # 从哪个快照分叉
  created_at: timestamp
  status: active | archived | merged
```

**分支操作：**
| 操作 | 说明 |
|------|------|
| 创建分支 | 从任意快照创建新的独立演进线 |
| 切换分支 | 在不同分支间切换工作上下文 |
| 归档分支 | 不再活跃但保留历史 |
| 合并分支 | 将一个分支的变更合并到另一个（需确认冲突） |

**回溯后的操作模式：**
| 模式 | 行为 |
|------|------|
| 查看 | 只读浏览，不创建分支 |
| 分叉继续 | 创建新分支，原分支保留 |
| 回滚删除 | 回到该快照，删除后续事件（危险操作，需二次确认） |
| 回溯重构 | 在该快照上修改，触发 Activation Edge 全链路重新评估，所有下游变更需用户逐一确认 |

### 分支合并的冲突解决

当两个分支都修改了同一个 Context Unit 时，需要解决冲突：

**冲突解决策略：**
| 策略 | 行为 | 适用场景 |
|------|------|----------|
| `latest_wins` | 后修改的版本胜出 | 低风险、快速合并 |
| `source_wins` | 源分支版本胜出 | 信任源分支 |
| `target_wins` | 目标分支版本胜出 | 保守合并 |
| `manual_review` | 进入确认中心，用户逐个决定 | 高风险或重要变更 |
| `side_by_side` | 并排展示差异，用户选择或编辑 | 需要精细控制 |

**默认策略：** `manual_review`（保留人类决策权）

---

### 回溯重构的两阶段方案

当用户选择「回溯重构」时，系统采用两阶段处理以降低复杂度：

**阶段一：机械批量替换**
```yaml
场景: 名称变更、术语统一等机械性修改
流程:
  1. 系统列举所有受影响的位置
  2. 用户选择：把 [旧值] 批量替换为 [新值]
  3. 系统在该分支上全量执行替换
  4. 记录为单个事件（包含所有变更位置）
  
日常可用: true  # 批量替换也作为日常功能提供
```

**阶段二：时序逐层重构**
```yaml
场景: 语义性变更，需要 AI/人类重新评估
规则:
  - 必须按时间顺序逐层处理（保证因果一致性）
  - 每层的 Maintainer Agent 评估是否需要变更
  - 人类参与决策

流程:
  1. 系统计算影响链（按时间/依赖层级排序）
  2. 显示警告：「将影响 X 个单元，预计需要 Y 轮确认」
  3. 逐层推进：第 N 层完成后才进入第 N+1 层
  4. 每层可选：逐个确认 / 本次批量同意 / YOLO 模式
  5. 关联的 archived 结果标记为「待审查」
```

**设计原则：**
- 机械替换先行，减少后续语义评估数量
- 时序约束保证因果一致性
- 保留人类决策权，但提供效率选项

**价值**：安全的实验性修改、完整的版本历史、可控的大规模重构。

---

## 问题 14：如何引用历史状态或其他分支的变量值？（Query Scope）

### 问题背景
在某些场景下，用户需要引用的不是变量的「当前值」，而是「某个历史快照的值」或「另一个分支的值」。

### 挑战
> 例：写第50章时，需要引用「第49章定稿时」的角色状态，而非当前编辑中的状态。如何让用户配置这种引用？

### 讨论
- 这是一个查询作用域问题；
- 不应要求用户写代码，需要预定义的查询模式；
- 应可在 Prompt/规则设计时可视化配置。

### 结论
**Query Scope（查询作用域）作为引用语法扩展**

**预定义查询模式：**
| 模式 | 语法 | 含义 |
|------|------|------|
| 默认（当前） | `{{变量}}` | 当前分支最新状态 |
| 指定快照 | `{{变量 @snapshot="名称"}}` | 指定快照时的状态 |
| 指定分支 | `{{变量 @branch="名称"}}` | 指定分支的最新状态 |
| 相对位置 | `{{变量 @snapshot=-1}}` | 上一个快照的状态 |

**在可视化界面配置：**
用户在配置 Prompt 引用变量时，可选择：
- 「使用当前值」（默认）
- 「使用快照值」→ 选择快照
- 「使用分支值」→ 选择分支
- 「使用相对快照」→ 输入偏移量

### UI 约束选择模式

**核心原则：凡是有限集合的选择，都用 UI 约束而非自由输入。**

用户在引用变量时的交互流程：
1. 点击「添加引用」
2. 选择查询范围：「当前」/「指定快照」/「指定分支」
3. 弹出选择器面板：
   - 滑动浏览可用的变量/卡片
   - 或搜索查询
   - 只显示在所选范围内存在的项
4. 选中后，系统自动生成语法

**该模式的广泛应用：**
| 场景 | 自由输入（❌ 不用） | 约束选择（✅ 采用） |
|------|---------------------|---------------------|
| 引用变量 | 手写 `{{变量名}}` | 从列表选择 |
| 选择快照 | 手写快照名 | 从快照列表选择 |
| 配置 Agent | 输入 Agent ID | 从 Agent 列表选择 |
| 绑定模型 | 输入模型名 | 从可用模型选择 |

**价值：**
- 杜绝无效引用（不存在的变量、快照等）
- 降低学习成本（无需记忆命名规则或语法）
- 提高配置效率

**Agent 规则中的查询配置：**
```yaml
# 在 Agent 规则中指定其查询范围
agent_config:
  default_query_scope: latest  # 默认查当前
  allowed_scopes: [latest, snapshot, branch]  # 允许的查询范围
  restricted_branches: ["实验分支"]  # 禁止访问的分支
```

**价值**：灵活引用历史/分支状态、无需写代码、权限可控。

---

## 问题 15：如何保证大规模项目的性能？

### 问题背景
Event Sourcing + Snapshot + Branch 组合下，长期运行的项目（如长篇小说创作一年）可能产生数万个事件、数百个快照、多个分支。如何保证查询和操作的性能？

### 挑战
> 如果每次查询都要重放所有事件，系统会变得极慢。如何在「全量存储」和「快速查询」之间取得平衡？

### 讨论
- 核心理念：**全量无损存储 + 按需激活查询范围**
- 技术栈：Rust（性能关键路径）+ TypeScript（UI 和业务逻辑）
- 存储层保留一切，查询层按需加载

### 结论
**性能架构：全量存储 + 按需激活**

**技术分层：**
```
┌─────────────────────────────────────┐
│          TypeScript 层              │
│   (UI, 业务逻辑, API 编排)          │
└──────────────┬──────────────────────┘
               │ FFI / WASM
┌──────────────▼──────────────────────┐
│            Rust 层                  │
│   (Event Store, 查询引擎, 状态投影) │
└─────────────────────────────────────┘
```

**Rust 负责的性能关键路径：**
| 功能 | 技术手段 |
|------|----------|
| Event 存储 | Append-only，零拷贝写入 |
| 快照生成 | 增量快照（只记录变化） |
| 状态投影 | `最近快照 + 后续事件` 重建 |
| 范围查询 | 按 Unit ID / 时间 / 边类型索引 |

**按需激活的查询逻辑：**
```
查询某 Unit 在某 Snapshot 的状态:
  1. 找到最近的基准快照
  2. 只加载该 Unit 相关的后续事件（非全量）
  3. 重放这些事件得到目标状态
```

**核心原则：**
- 存储层：全量、无损、永不删除
- 查询层：按需、范围限定、惰性加载

**价值**：历史完整可追溯、查询性能可控、支持大规模长期项目。
