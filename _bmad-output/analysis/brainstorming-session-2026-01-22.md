---
stepsCompleted: [1]
inputDocuments: ['总体想法.md']
session_topic: '通用 AI 上下文工程系统设计完善与风险识别'
session_goals: '将构想从想法稿升级为可执行的系统设计蓝图'
selected_approach: 'progressive-flow'
techniques_used: ['First Principles Thinking', 'Morphological Analysis', 'Six Thinking Hats', 'Constraint Mapping']
ideas_generated: []
context_file: '总体想法.md'
---

# Brainstorming Session Results

**Facilitator:** 耶稣
**Date:** 2026-01-22

## Session Overview

**Topic:** 通用 AI 上下文工程系统（工作台）——设计完善与风险识别
**Goals:** 验证核心概念、收敛开放问题、发现潜在盲点、优化系统架构

### Context Guidance

输入文档`/Users/jingshun/Desktop/AI 上下文工程可视化项目/总体想法.md`描述了一个通用 AI 上下文工程系统的完整构想，包括：
- 核心抽象：上下文单元（变量 + 卡片）
- Agent 分层职责（系统级/变量级/审查级）
- 变更传播与溯源系统
- 微内核+插件化底层架构
- 6个待讨论的开放问题

### Session Setup

用户希望通过系统化的头脑风暴将这个初步构想梳理成熟，使项目变得更加健壮和可落地。

---

## Phase 1: 发散探索（First Principles Thinking）

### 摘要
本次头脑风暴以第一性原理审视原始设计，形成了 **14 个核心设计决策**：
1) 统一“变量/卡片”为 Context Unit；
2) 引入 active/archived 生命周期与“晋升”机制；
3) 区分 Reference/Activation/Containment/Derivation 四类关系边；
4) Tag + Policy 分离（分类与行为正交）；
5) Authority Source vs Maintainer 分离；
6) Trigger = Event + Condition + 安全阀；
7) ChangeSet/ImpactSet/Reason 结构化确认；
8) Event Sourcing 作为溯源底座；
9) 配置包版本化 + Migration；
10) UI 从“流程编排”转向“有机系统蓝图”；
11) Agent 推理过程纳入溯源（底层记录一切，用户层选择性开放）；
12) Snapshot 用户化（命名快照 + 多种创建方式）；
13) Branch 分支管理（独立演进线 + 分叉/合并）；
14) Query Scope 查询作用域（引用历史/分支状态的能力）。

---

## 背景：我们在挑战什么？
输入文档《总体想法.md》描述了一个通用 AI 上下文工程系统的初步构想。核心理念是：**LLM 本质无状态，要让 AI 在复杂长期任务中表现得“有状态、连贯、可控”，关键在于上下文工程。**
原始设计包含：变量/卡片、溯源系统、变量结果/卡片结果、四种确认模式等。我们用第一性原理挑战它们：是否存在更简洁且可扩展的抽象？

---

## 问题 1：变量和卡片真的是两个不同的东西吗？

### 问题背景
原始设计用“变量=原子”、“卡片=组合”的二元抽象。

### 挑战
> 「角色卡」能被「势力卡」引用为“变量”吗？若可以，二者的区分是否只是视角而非本质？

### 讨论
用户确认可以，并指出“变量们其实都是上下文包”。由此可见二者本质一致，只是粒度不同。

### 结论
**统一抽象：Context Unit（上下文单元）**
- 底层只有一种实体，可作为叶子或容器；
- “变量/卡片”留在 UI 作为视图/标签，而非底层结构。

**价值**：存储、权限、溯源、传播、查询、UI 复用同一机制，显著降复杂度。

---

## 问题 2：「变量」与「变量结果」的边界是什么？

### 问题背景
区分“变量=活数据”与“变量结果=固定产出”在实践易模糊。

### 挑战
> AI 写第三章正文引入新角色。应当：A) 仅留在结果；B) 自动提取为变量；C) 由用户决定是否提升？

### 讨论
- 否决 A：信息被锁在结果中，难以复用；
- 否决 B：自动膨胀，变量爆炸；
- 选择 C：保留人类最终决策权，按需纳入系统。

### 结论
**生命周期：active / archived + 晋升机制**
- `active`：参与依赖图、会触发传播、可修改；
- `archived`：只读存档、不触发传播、不入依赖网；
- **默认原则：AI 产出中新出现的实体/事实默认进入 `archived`，仅在确认后才可晋升为 `active`。**
- 支持 `archived → active`“晋升”，必须经确认并记录溯源。

**价值**：避免膨胀（默认不进系统网络）、保留决策权、不丢信息、过程可追溯。

---

## 问题 3：引用即依赖，但所有关系都是同一种“边”吗？

### 问题背景
原始设计把所有关系都视作“引用边”，易导致传播混乱与可视化负担。

### 挑战
> “包含关系”和“被规则引用”是同一种吗？“触发维护”和“派生来源”又是同一种吗？

### 讨论
不同关系语义与传播行为不同，需要区分与可视化过滤。

### 结论
**四种边类型**
| 边类型 | 语义 | 传播行为 | 示例 |
|---|---|---|---|
| Reference | 规则/Prompt 中引用 | ✅ 触发下游重新评估 | `{{角色A}}` 被写作规则引用 |
| Activation | A 变化激活 B 维护流程 | ✅ 触发 Maintainer 工作 | 角色死亡 → 激活相关状态更新 |
| Containment | 结构包含（父子） | ⚠️ 仅向上冒泡状态变化（脏标记），不向下游传播；是否进一步触发维护需显式规则 | 角色卡包含“姓名/性格” |
| Derivation | 派生/溯源 | ❌ 仅记录来源，不参与传播 | 第三章正文派生自角色卡+大纲 |

**价值**：UI 可按边类型过滤，传播规则清晰，契合“神经系统”隐喻。

---

## 问题 4：类型体系（CONST/SLOW/DYN）在统一抽象下怎么办？

### 问题背景
原始设计延续了传统变量类型分类：CONST（常量）、SLOW（缓慢变化）、DYN（动态）、FACT（事实）。这种分类体系假设变量有固定的“本质类型”。

### 挑战
> 如果一切都是 Context Unit，固定的四分类还有意义吗？一个变量能不能既是“人物相关”又是“高风险需审查”？

### 讨论
- 固定分类的问题：一个变量只能属于一种类型，但实际场景中往往需要多维度描述；
- 用户反馈：应该通过“标题、备注和 #标签”来分类，而非强制类型；
- 进一步区分：分类（是什么）和行为（怎么对待）是两件事，不应耦合。

### 结论
**Tag + Policy 分离**
- Tag 管“是什么”（如 `#人物` `#世界观` `#关键事实` `#不可变`）；
- Policy 管“怎么对待”（确认模式、可写 Agent、可用模型等）。

**Policy 结构示例：**
```yaml
Policy:
  confirmation_strategy: confirm_required  # immediate / confirm_required / batch_queue / auto_trusted
  allowed_maintainers: [Agent-A, Agent-B]
  allowed_models: [claude-3, gpt-4]
  requires_review: true
  max_auto_propagation_depth: 3
```

**价值**：分类与行为正交，最大灵活与可迁移性。

---

## 问题 5：`owner` 概念如何在通用系统中定义？

### 问题背景
原始设计《总体想法.md》第 11 节将 `owner` 概念列为开放问题：「在通用系统里是否应该下沉到模板？或者区分“权威源”与“维护权”」。

### 挑战
> 一个 Context Unit 的 owner 是指“谁有权修改它”还是“最终以谁的版本为准”？如果 AI Agent 提出修改建议，但人类是最终权威，如何表达这种关系？

### 讨论
- “owner”一词含义模糊：可能指创建者、维护者、或权威来源；
- 实际场景：一个角色设定可以是“人类为最终权威”+“AI Agent 负责监控和建议修改”；
- 需要分离两个概念：谁说了算（冲突时）vs 谁负责日常维护。

### 结论
**Authority Source vs Maintainer 分离**
- Authority Source：冲突时以谁为准（人类/外部文档/系统/Agent）；
- Maintainer：谁负责提更新建议（Agent/人类/规则）。

**价值**：消除歧义，权限/职责更精确。

---

## 问题 6：触发机制够不够？条件/批量/链式爆炸如何处理？

### 问题背景
原始设计列出四种触发类型：用户输入、关联变量变更、定时触发、外部调用。这些是否足够覆盖实际场景？

### 挑战
> 1. 条件触发怎么办？比如“当章节数 > 10 时自动触发某流程”。
> 2. 批量触发怎么办？用户选中一组变量统一更新。
> 3. 链式爆炸怎么办？A→B→C→D 形成长链时，如何防止无限传播？

### 讨论
- 四种触发本质是**事件源**，不是触发机制本身；
- 条件触发 = 事件源 + 条件过滤，不需要新增“第五种触发”；
- 批量触发 = 多个事件的聚合处理，应在确认中心支持；
- 链式爆炸需要系统级安全阀，而非依赖用户配置。

### 结论
**Trigger = Event + Condition + 安全阀**
- 事件源：user_input / unit_changed / time_tick / external_call / 自定义；
- 条件：可选的过滤规则，满足时才触发；
- 安全阀：最大传播深度、频率限制/去抖、`impactSet` 超阈强制人工确认。

**价值**：可扩展（不用加新触发类型）、不易过时、安全可控。

---

## 问题 7：确认机制如何结构化？

### 问题背景
原始设计提出四种确认模式：严格、宽松、批量接受、YOLO。这是正确方向，但“确认”的数据结构是什么？

### 挑战
> 用户在确认时需要知道什么？只是“接受/拒绝”吗？还是需要看到完整的变更上下文？

### 讨论
- 如果只是“是/否”开关，用户无法做出明智决策；
- 用户需要知道：要改什么（ChangeSet）、会影响谁（ImpactSet）、为什么要改（Reason）；
- 四种模式本质是“谁可以自动提交 ChangeSet”和“什么情况必须人工介入”的策略配置。

### 结论
**ChangeSet + ImpactSet + Reason**
- ChangeSet：要改哪些单元、改成什么（可拆分接受）；
- ImpactSet：会影响哪些下游（按层级/边类型计算）；
- Reason：为何而改（触发事件 trigger、证据引用 evidence refs、可选 agent rationale）。
- 执行策略：immediate / confirm_required（默认）/ batch_queue / auto_trusted。

**价值**：让确认基于完整上下文，不是“是/否”开关；策略可按 Tag/Policy 精细配置。

---

## 问题 8：溯源系统应当是模块还是地基？

### 问题背景
原始设计将溯源称为“系统灵魂”，并列为十大模块之一。但这种定位是否足够？

### 挑战
> 如果溯源只是“模块之一”，它就可能被绕过或事后补充。如何让“强制溯源”成为架构必然而非约定？

### 讨论
- 溯源不应是“事后记录”，而应是“系统事实的定义方式”；
- Event Sourcing 架构：当前状态 = 所有事件的折叠结果；
- 这样溯源不是可选功能，而是数据存储的本质——无法绕过。

### 结论
**Event Sourcing 作为溯源底座**
- Event Store：不可变事件记录（谁在何时因何对哪些单元做了什么）；
- Projection：当前状态视图（由事件计算得出）；
- Snapshot：性能优化的状态快照；
- 统一 Query API：UI 和 Agent 共用同一套查询接口。

**价值**：强制溯源（架构必然）、时间旅行、Undo/Redo、Diff 对比、统一查询模型。

---

## 问题 9：模板/配置包会过时，如何安全升级？

### 问题背景
核心哲学是“系统不过时，模板可过时”。但如果官方小说模板升级了 schema，用户项目怎么办？

### 挑战
> 一年后你升级官方模板，用户的旧项目能否平滑迁移？如果不能，核心愿景就会被破坏。

### 讨论
- 没有 migration 机制，模板升级会导致用户项目崩溃；
- 这不是“以后再考虑”的问题，必须从第一天设计；
- 配置包需要版本号 + 迁移规则。

### 结论
**版本化 + Migration**
- 配置包声明 `schemaVersion`；
- 提供从旧版本的迁移脚本/规则（哪怕初期很简单）；
- 系统在加载配置包时检测版本，自动或提示运行迁移。

**价值**：兑现“系统不过时，模板可过时”的核心承诺；用户项目可安全升级。

---

## 问题 10：与 Dify 的本质区别是什么？（范式转换）

### 范式对比
| 维度 | Dify 范式 | 本项目范式 |
|---|---|---|
| 构建思维 | 流程图：A→B→C | 有机系统：设计器官与相互作用 |
| 核心问题 | 下一步做什么 | 系统需要哪些器官，如何协同 |
| 执行模型 | 顺序/并行 | 事件驱动 + 相互响应 |
| 变更模型 | 手动触发下一步 | 变更沿“神经系统”传播 |

### 结论（UI 必须体现）
- 主视图=“系统蓝图”，卡片=“器官”，连线=“神经/血管”，溯源=“神经系统扫描”；
- 构建起点是“需要哪些器官”，而非“第一步做什么”。

---

## Phase 1 总结：14 个核心设计决策

| # | 决策 | 核心理由 |
|---|---|---|
| 1 | 统一为 Context Unit | 降复杂、机制复用 |
| 2 | active/archived + 晋升 | 避免膨胀、保决策权、可追溯 |
| 3 | 四类边（Reference/Activation/Containment/Derivation） | 传播清晰、可视化友好 |
| 4 | Tag + Policy | 分类/行为正交、可迁移 |
| 5 | Authority vs Maintainer | 权限与职责精确化 |
| 6 | Event + Condition + 安全阀 | 可扩展与安全控制 |
| 7 | ChangeSet/ImpactSet/Reason | 基于完整信息的确认 |
| 8 | Event Sourcing | 溯源为地基、时间旅行 |
| 9 | 包版本化 + Migration | 模板安全升级 |
| 10 | UI 范式：有机系统蓝图 | 引导正确心智模型 |
| 11 | Agent 推理溯源 | 底层记录一切、用户层选择性开放 |
| 12 | Snapshot 用户化 | 版本管理、可回溯、可命名 |
| 13 | Branch 分支管理 | 独立演进、实验性修改、安全回滚 |
| 14 | Query Scope 查询作用域 | 引用历史/分支状态、灵活配置 |

---

## 待议事项（后续 Phase 讨论）

**✅ 已解决：术语冲突**
- 原“Trigger 边”已改名为 **Activation Edge**（表示“A 变化激活 B 维护流程”的关系）
- **Trigger Rule**：Event + Condition + 安全阀（规则配置对象）
- 两者现已明确区分

**✅ 已补充：Containment 边的向下广播规则**

**ContainmentEdge 的可选配置：**
```
├── bubbleUp: true（默认）——子级变化向上冒泡脏标记
├── broadcastDown: false（默认）——父级变化不自动向下广播
└── broadcastRules: [可选] 定义哪些父级属性变化时广播给哪些子级
```

**配置示例：**
```yaml
# 势力卡的 Containment Policy
containment:
  broadcastRules:
    - when: "阵营立场" changed
      notify: all children with tag #角色
      action: suggest_review  # 建议审查，而非强制更新
```

**设计原则：**
- 默认行为简单（不广播），降低认知负担
- 高级用户可配置复杂规则
- 广播动作默认为 `suggest_review`（建议审查），而非 `force_update`（强制更新），保留人类决策权

---

## 问题 11：Agent 推理过程如何纳入溯源？

### 问题背景
每个变量/卡片可以绑定 AI Agent 负责。当 Agent-A 更新变量 X 后，关联变量的 Agent-B 会收到通知。Agent-B 可能需要查询“Agent-A 为什么更新 X”来做出更准确的判断。

### 挑战
> 溯源系统是否需要记录 Agent 的完整推理过程？Agent 对溯源系统的查询本身是否也要记录？

### 讨论
- 底层设计理念：**底层记录一切，用户层选择性开放**
- Agent 的完整推理过程（Chain of Thought）应该记录
- Agent 的溯源查询行为本身也应该记录
- 这符合核心理念：高度模块化底层 + 高度用户自定义 = 立于不败之地

### 结论
**Event 结构扩展：**
```yaml
Event:
  # 基础信息
  timestamp, actor, action, subject, changes
  
  # Agent 推理上下文（新增）
  reasoning:
    trigger_event: 触发此次更新的事件
    inputs_read: Agent 读取了哪些 Context Unit
    traceability_queries: Agent 做了哪些溯源查询
    chain_of_thought: Agent 完整推理过程
    conclusion: 最终结论
  
  # 传播信息（新增）
  notifications_sent: 通知了哪些下游 Agent
```

**Agent 溯源查询 API：**
| 查询 | 权限级别 |
|------|----------|
| `getLatestChange(X)` | 基础 |
| `getChangeTrigger(X)` | 标准 |
| `getAgentRationale(X)` | 高级 |
| `getInputsConsidered(X)` | 高级 |
| `traceBack(X, depth)` | 完整 |

**关键原则：**
- 底层 Event Store 记录一切（推理过程、查询行为、通知记录）
- 用户可配置每个 Agent 的查询权限级别
- 用户可在 Agent 规则（Prompt）中指定何时调用溯源查询

**价值：**Agent 间协作有据可查、可追溯、可调试；用户可按需控制复杂度。

---

## 问题 12：如何支持项目级的版本管理与回溯？

### 问题背景
复杂项目（如长篇小说、大型软件项目、法律案件等）需要在不同阶段保存进度，并能回溯到历史状态。Event Sourcing 提供了事件级的历史记录，但用户需要更高层次的「项目快照」能力。

### 挑战
> 用户需要：1) 定期保存项目完整状态；2) 回溯到某个历史节点；3) 从历史节点分叉继续工作而不丢失原进度。

### 讨论
- Event Sourcing 已有 Snapshot 概念（用于性能优化），但不是用户可操作的；
- 用户需要的是「命名的、可管理的」快照，类似 Git 的 commit；
- 回溯后的操作需要支持多种模式：查看、继续、重构。

### 结论
**Snapshot 升级为用户可操作的版本管理能力**

```yaml
Snapshot:
  id: "snapshot-uuid"
  name: "第49章定稿"          # 用户命名
  created_at: timestamp
  created_by: user | system | schedule
  branch: "main"
  description: "完成第49章，角色关系稳定"  # 可选备注

  # 创建方式
  triggers:
    - manual: 用户手动创建
    - scheduled: 定时自动创建（如每小时/每天）
    - event: 特定事件触发（如「章节标记为完成」）
```

**用户操作：**
| 操作 | 说明 |
|------|------|
| 创建快照 | 保存当前项目完整状态 |
| 查看快照 | 只读浏览历史状态 |
| 回溯到快照 | 将项目状态恢复到该快照（详见问题 13 的分支处理） |
| 对比快照 | Diff 两个快照之间的变化 |

**价值**：项目级版本管理、安全回溯、进度可视化。

---

## 问题 13：回溯后如何处理？（分支管理）

### 问题背景
当用户回溯到历史快照后，有多种可能的后续操作。需要支持 Git 式的分支管理。

### 挑战
> 用户回溯到「第30章定稿」后，可能想：A) 查看当时状态；B) 从此处分叉继续，保留原进度；C) 回滚并删除后续进度；D) 修改后触发全链路重构。

### 讨论
- 简单的「撤销/重做」不够，需要分支概念；
- 分支允许实验性修改而不影响主线；
- 「回溯重构」是特殊场景：修改历史节点后，所有相关变量需要重新评估。

### 结论
**Branch（分支）作为平台能力**

```yaml
Branch:
  id: "branch-uuid"
  name: "主线" | "第30章重写实验"
  parent_snapshot: "snapshot-xxx"  # 从哪个快照分叉
  created_at: timestamp
  status: active | archived | merged
```

**分支操作：**
| 操作 | 说明 |
|------|------|
| 创建分支 | 从任意快照创建新的独立演进线 |
| 切换分支 | 在不同分支间切换工作上下文 |
| 归档分支 | 不再活跃但保留历史 |
| 合并分支 | 将一个分支的变更合并到另一个（需确认冲突） |

**回溯后的操作模式：**
| 模式 | 行为 |
|------|------|
| 查看 | 只读浏览，不创建分支 |
| 分叉继续 | 创建新分支，原分支保留 |
| 回滚删除 | 回到该快照，删除后续事件（危险操作，需二次确认） |
| 回溯重构 | 在该快照上修改，触发 Activation Edge 全链路重新评估，所有下游变更需用户逐一确认 |

**回溯重构流程：**
1. 用户在历史快照上修改某个 Context Unit
2. 系统计算 ImpactSet（所有受影响的下游单元）
3. 沿 Activation Edge 逐层触发 Maintainer 重新评估
4. 每个变更生成 ChangeSet，进入确认中心
5. 用户逐一确认或批量处理
6. 关联的 archived 结果（如已写章节）标记为「待审查」

**价值**：安全的实验性修改、完整的版本历史、可控的大规模重构。

---

## 问题 14：如何引用历史状态或其他分支的变量值？（Query Scope）

### 问题背景
在某些场景下，用户需要引用的不是变量的「当前值」，而是「某个历史快照的值」或「另一个分支的值」。

### 挑战
> 例：写第50章时，需要引用「第49章定稿时」的角色状态，而非当前编辑中的状态。如何让用户配置这种引用？

### 讨论
- 这是一个查询作用域问题；
- 不应要求用户写代码，需要预定义的查询模式；
- 应可在 Prompt/规则设计时可视化配置。

### 结论
**Query Scope（查询作用域）作为引用语法扩展**

**预定义查询模式：**
| 模式 | 语法 | 含义 |
|------|------|------|
| 默认（当前） | `{{变量}}` | 当前分支最新状态 |
| 指定快照 | `{{变量 @snapshot="名称"}}` | 指定快照时的状态 |
| 指定分支 | `{{变量 @branch="名称"}}` | 指定分支的最新状态 |
| 相对位置 | `{{变量 @snapshot=-1}}` | 上一个快照的状态 |

**在可视化界面配置：**
用户在配置 Prompt 引用变量时，可选择：
- 「使用当前值」（默认）
- 「使用快照值」→ 选择快照
- 「使用分支值」→ 选择分支
- 「使用相对快照」→ 输入偏移量

**系统自动生成语法**，用户无需手写。

**Agent 规则中的查询配置：**
```yaml
# 在 Agent 规则中指定其查询范围
agent_config:
  default_query_scope: latest  # 默认查当前
  allowed_scopes: [latest, snapshot, branch]  # 允许的查询范围
  restricted_branches: ["实验分支"]  # 禁止访问的分支
```

**价值**：灵活引用历史/分支状态、无需写代码、权限可控。
