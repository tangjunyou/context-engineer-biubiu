---
stepsCompleted: ['step-01-init', 'step-01b-continue', 'step-02-discovery', 'step-03-success', 'step-04-journeys', 'step-05-domain', 'step-06-innovation']
inputDocuments:
  - '_bmad-output/planning-artifacts/product-brief-AI 上下文工程可视化项目-2026-01-29.md'
  - '_bmad-output/analysis/brainstorming-session-2026-01-22.md'
  - '总体想法.md'
  - '拓展信息/项目技术方案第二版（GPT）.md'
documentCounts:
  briefs: 1
  research: 0
  brainstorming: 1
  projectDocs: 2
workflowType: 'prd'
workflow: 'edit'
classification:
  projectType: 'Platform + Developer Tool + Creative Tool'
  domain: 'AI Infrastructure + Creative Tools'
  complexity: 'Very High'
  projectContext: 'greenfield'
  innovationPositioning: 'New Paradigm: AI Organism'
  technicalCharacteristics: 'State-Intensive System'
lastEdited: '2026-01-31'
editHistory:
  - date: '2026-01-31'
    changes: '添加Product Overview章节；完善Success Criteria（用户成功定义、失败阈值）；Journey版本边界标注；添加系统底线章节；更新技术债务检查清单'
---

# Product Requirements Document - AI 上下文工程可视化项目

**Author:** 耶稣
**Date:** 2026-01-29

## Product Overview

### 项目背景与动机

**原始动机**（来自总体想法.md）：
> 最初从"AI 写中文网络长篇高质量爆款小说"出发，认为当前的核心阻塞主要是：
> 1. 稳定产出质量（输出质量波动大）
> 2. 长篇一致性问题（人物、设定、时间线、状态持续一致非常难）
> 3. 创意设计问题（设定/剧情结构/伏笔回收等需要系统化支撑）

**核心洞察**：
AI 本质无状态。是精密的上下文工程设计让 AI 有了状态——让 AI Agent 真正"活"了起来。

### 产品定义

**AI 上下文工程可视化项目**是一个 **AI 有机体构建平台**——不是编排 AI 的"动作"，而是让用户设计 AI 的"存在"。

我们构建的是：
- 一个通用的 AI 上下文工程平台（高度模块化底层）
- 一套小说创作官方模板（验证场景）

遵循"一花一世界"的设计哲学——以具体场景为锚，以通用机制为本。

### 核心价值主张

> "让 AI 真正'活'起来" —— 通过上下文工程设计赋予 AI 状态，让用户清晰感知 AI 记住了他们的设定。

**关键差异化**（来自 Product Brief）：

| 维度 | 本项目 | 现有方案（Dify/LangChain） |
|------|--------|---------------------------|
| 核心范式 | 设计 AI 的"存在"（有机体） | 编排 AI 的"动作"（工作流） |
| 状态管理 | 系统化上下文工程，赋予 AI 真正的状态 | prompt + workflow，本质无状态 |
| 人机协同 | 围绕项目状态（变量）共同管理 | 人发指令，AI 执行 |
| 可视化 | 有机系统蓝图，可感知"活着的系统" | 工作流图/节点图 |

### 目标用户

**L1 有机体设计师**（直接使用平台）
- 独立创作者（如林远）：设计角色卡、世界观卡、章节结构
- 技术开发者（如张涛）：设计复杂AI有机体（如情感陪伴AI）

**L2 有机体运营者**（直接使用平台）
- 与AI协同管理有机体的日常运转
- 企业团队（如游戏世界观组）：多人协作维护

**L3 有机体消费者**（不直接使用平台）
- 使用AI有机体服务输出的终端用户

### 成功画面

当用户使用这个平台时，他们能感知到：

> **一个"活着的系统"**——每个变量（器官）之间的关联清晰可见，变更沿着"神经系统"自动传播，AI Agent 像系统内部的员工一样持续感知和响应。整个有机体在呼吸、在运转。

---

## Success Criteria

> **核心成功验证问题：** 用户是否真的感知到"AI有状态"带来的价值差异？
>
> 本项目的成功不是功能堆砌或用户数增长，而是验证一个根本命题：**通过上下文工程赋予AI状态，能让AI真正"活"起来，并被用户清晰感知。**
> 本项目的技术选型参考文档为"拓展信息/项目技术方案第二版（GPT）.md"，本参考文档不是最终确定版，仅供参考。

### User Success

**用户如何知道这个产品对他们有用？**

| 用户类型 | 成功标志 |
|----------|----------|
| **独立创作者（林远）** | "AI终于记住我的角色了！改了设定它会自动提醒我哪些章节需要调整。"不再收到读者的"设定矛盾"投诉。 |
| **技术开发者（张涛）** | "终于可以设计一个真正'活着'的AI，而不是一堆流程节点。"导出的AI有机体能够持续记住用户的故事。 |
| **企业团队（世界观组）** | "每个人负责自己的模块，改动自动同步，再也不用开会对设定了。"每周设定争议从8-10次降到1-2次。 |

### 指标与愿景对齐验证

| 核心愿景 | 验证指标 | 逻辑 |
|----------|----------|------|
| "让AI有状态" | 状态感知率、跨会话记忆验证率 | 如果用户感知不到状态，核心价值失败 |
| "设计AI的存在" | 有效关联变量数、语义化命名率 | 如果用户不在"设计有机体"，定位失败 |
| "AI活起来了" | 首次"哇"时刻时间、主动关联发起率 | 如果用户不惊艳，MAV定位失败 |
| "高度用户自定义" | 模板修改率、自定义配置比例、配置存活率 | 如果只用默认，用户创造自由度未被发挥 |

### User Success

#### AI"活性"验证指标（核心差异化验证）

| 指标 | 定义 | 目标 | 为什么重要 |
|------|------|------|------------|
| 主动关联发起率 | AI主动发现并提示的关联/问题，占所有关联提示的比例 | ≥30% | 这才是"活着"的证明，而非"被动响应" |
| 跨会话记忆验证率 | 用户在新会话中测试，AI仍能正确引用历史设定的比例 | ≥90% | 真正的"有状态"意味着跨会话持续 |
| 一致性零矛盾天数 | AI建议与项目历史无逻辑矛盾的连续天数 | 连续7天 | 这是"连贯性"的直接证明 |
| 状态感知率 | 用户修改变量后，触发关联提示的比例 | ≥80% | 验证"变更传播"机制生效 |
| 首次"哇"时刻时间 | 用户从上手到体验第一个自动关联的时间 | ≤10分钟 | 验证上手体验达标（MAV定位） |

#### 用户行为成功指标

| 指标 | 定义 | 目标 | 为什么重要 |
|------|------|------|------------|
| 有效关联变量数 | 被至少3条边连接的Context Unit数量 | ≥20个/项目 | 用户在认真构建"神经系统" |
| AI建议采纳后未修改率 | 用户接受AI建议后未再修改的比例 | ≥70% | 采纳且不改 = AI建议真正有价值 |
| 7日项目活跃率 | 7日内项目有任何变更的比例 | ≥40% | 产品有持续价值 |
| 语义化命名率 | Context Unit使用语义名称而非默认名称的比例 | ≥80% | 用户用"器官"思维而非"节点"思维 |

#### 分用户类型成功指标

| 用户类型 | 核心成功指标 | 目标 |
|----------|--------------|------|
| 独立创作者 | 长篇项目持续率（10章→30章） | ≥30% |
| 技术开发者 | 成功导出可运行有机体的用户比例 | ≥50% |
| 企业团队 | 多人协作项目持续活跃≥30天的比例 | ≥60% |

#### 体验层级进阶指标

| 指标 | 定义 | 目标 |
|------|------|------|
| L1→L2进阶率 | 使用协作功能的用户比例 | ≥60% |
| L2→L3进阶率 | 进入高级设置的用户比例 | ≥20% |
| 各层级满意度 | 每层体验评分 | ≥4.0/5 |

#### 高度用户自定义验证指标

| 指标 | 定义 | 目标 | 为什么重要 |
|------|------|------|------------|
| 模板修改率 | 用户对官方模板进行自定义调整的比例 | ≥30% | 用户在发挥创造力 |
| 自定义配置比例 | 用户创建的原创变量/规则占比 | ≥20% | 平台的自定义价值被使用 |
| 用户原创模板数 | 用户分享的原创模板数量 | 持续增长 | 生态健康度 |
| 自定义配置7日存活率 | 用户自定义的规则/Policy在7天后仍在使用的比例 | ≥70% | 自定义功能真正有效 |

### Business Success

#### 阶段性业务目标

| 阶段 | 时间 | 核心目标 | 关键指标 |
|------|------|----------|----------|
| MAV验证期 | 0-3个月 | 验证核心价值主张 | 种子用户留存≥50%，NPS≥40 |
| 产品市场契合 | 3-6个月 | 确认PMF | 自然增长占比≥30%，付费转化≥5% |
| 规模化增长 | 6-12个月 | 扩大用户基础 | 月活用户≥10,000 |
| 生态建设 | 12个月+ | 建立模板生态 | 社区模板≥100个 |

#### 竞争力验证指标

| 指标 | 定义 | 目标 |
|------|------|------|
| 同任务效率提升比 | 与Dify完成同样任务的步骤数/时间对比 | ≥50%提升 |
| NPS中提及"AI有状态"比例 | 推荐原因中提到核心价值的比例 | ≥50% |

#### 商业模式指标（如适用）

| 指标 | 定义 | 目标 |
|------|------|------|
| 免费→付费转化率 | 试用用户转付费的比例 | ≥5% |
| 用户生命周期价值(LTV) | 付费用户平均贡献收入 | 取决于定价策略 |
| 客户获取成本(CAC) | 获取一个付费用户的成本 | LTV/CAC ≥ 3 |

#### 失败阈值定义（何时 Pivot 或放弃）

| 验证阶段 | 指标 | 失败阈值 | 对应动作 |
|----------|------|----------|----------|
| MAV验证期（0-3个月） | 种子用户7日留存率 | < 30% | 重新审视UX设计，考虑Pivot |
| MAV验证期（0-3个月） | 首次"哇"时刻转化率 | < 50% | 重新设计上手体验 |
| MAV验证期（0-3个月） | NPS评分 | < 20 | 核心价值主张未被感知，需重新定位 |
| 产品市场契合（3-6个月） | 自然增长占比 | < 15% | 产品不具备自传播能力，需重新评估 |
| 产品市场契合（3-6个月） | 付费转化率 | < 2% | 商业模式不可行，需重新设计 |

### Technical Success

#### 性能指标

| 指标 | 定义 | 目标 |
|------|------|------|
| 1000 Units传播延迟 | 中等规模项目的传播响应时间 | ≤500ms |
| 5000 Units项目加载时间 | 大型项目的打开时间 | ≤5秒 |
| 增量传播率 | 能增量计算而非全量重算的传播比例 | ≥90% |
| Event写入吞吐 | 支撑实时协作的写入能力 | ≥1000/s |
| API可用性 | 系统正常运行时间比例 | ≥99.5% |

#### 开发者体验指标

| 指标 | 定义 | 目标 |
|------|------|------|
| 错误信息可操作率 | 错误信息包含解决建议的比例 | ≥90% |
| API文档覆盖率 | API接口有完整文档的比例 | 100% |
| 问题平均诊断时间 | 开发者定位问题的平均时间 | ≤15分钟 |
| 导出有机体冷启动时间 | 导出后首次启动时间 | ≤3秒 |

#### 协作成功指标

| 指标 | 定义 | 目标 |
|------|------|------|
| 冲突解决平均时间 | 两人同时修改同一设定的解决时间 | ≤5分钟 |
| 关键变更通知确认率 | 相关人员确认收到重要变更通知的比例 | ≥95% |
| 通知聚合率 | 相关变更合并通知而非逐条的比例 | ≥70% |

### Measurable Outcomes

#### 核心KPI仪表盘（按优先级）

| 优先级 | KPI | 测量方式 | 目标 | 频率 |
|--------|-----|----------|------|------|
| **P0** | 首次"哇"时刻转化率 | 用户首次触发自动关联的比例 | ≥80% | 日 |
| **P0** | 7日项目活跃率 | 7天后仍有项目活动的用户比例 | ≥40% | 周 |
| **P1** | 项目完成率 | 用户创建的项目达到"可用状态"的比例 | ≥30% | 周 |
| **P1** | AI建议采纳后未修改率 | 用户接受变更建议后未再修改的比例 | ≥70% | 周 |
| **P2** | 模板使用率 | 使用官方模板vs从空白开始的比例 | ≥70%使用模板 | 月 |
| **P2** | 社区贡献率 | 用户分享模板/配置的比例 | ≥5% | 月 |

#### 领先指标（预测成功）

| 指标 | 定义 | 目标 |
|------|------|------|
| 模板引导完成率 | 用户完成引导流程的比例 | ≥80% |
| 第一个关联建立时间 | 从开始到建立首个关联的时间 | ≤3分钟 |
| 日活Context Unit数/项目 | 项目的"心跳"指标 | ≥5个 |

#### 关联指标（体验链路验证）

| 指标 | 定义 | 目标 |
|------|------|------|
| 因延迟导致操作放弃率 | 用户因等待而放弃操作的比例 | ≤5% |
| 错误后继续使用率 | 用户遇错后没有离开的比例 | ≥90% |
| 冲突后内容一致性检查通过率 | 解决冲突后内容仍保持一致的比例 | ≥95% |

#### 反指标（避免虚荣追求）

| 不追求 | 为什么 | 替代关注 |
|--------|--------|----------|
| 注册用户总数 | 虚荣指标，不代表价值 | 活跃用户数、留存率 |
| 页面访问量 | 不代表用户获得价值 | 核心功能使用率 |
| AI调用次数 | 多不代表好 | AI建议采纳率、满意度 |
| 功能数量 | 堆功能不是目标 | 核心功能完成率 |

## Product Scope

### MVP - Minimum Viable Product

**定位：MAV（最小惊艳版本）** — 用户在10分钟内体验到"哇"，核心价值主张被清晰感知。

**核心交付：**
- 统一抽象：Context Unit + 四种边类型 + Tag + Policy
- 三种运行模式：单人工作台（完整）+ 多人工作台（基础）+ 自动化模式（配置）
- Event Sourcing 源系统 + 确认机制
- 小说创作官方模板（8种预设类型 + 4个预设Agent）
- 完整UI/UX（三层体验架构 + 有机系统蓝图）

**成功验证标准：**
- 首次"哇"时刻转化率 ≥80%
- 7日项目活跃率 ≥40%
- NPS ≥40

### Growth Features (Post-MVP)

**V1.5 扩展：**
- 完整因果链可视化与操作
- 复杂冲突处理与多级审批流程
- AI设定矛盾主动检测
- 跨分支查询能力

**V2.0 愿景：**
- 两阶段回溯重构
- 专业运维仪表盘与高级监控
- 多方协商确认机制
- 完整开放生态

### Vision (Future)

**长期愿景（2-3年）：**
- 成为AI有机体构建的行业标准平台
- 覆盖小说创作、游戏世界构建、企业知识管理等多场景
- 建立活跃的模板生态和开发者社区
- 让"AI有机体"成为新的产品范式

## User Journeys

### 设计原则

1. **人物保持一致**：严格使用Product Brief定义的用户画像细节
2. **时间指标对齐**：首次"哇"≤10分钟，第一个关联≤3分钟
3. **能力边界清晰**：仅涉及MAV范围能力，V1.5/V2.0功能明确标注"未来"
4. **骨架来自文档**：以Product Brief已有的旅程框架为基础深化叙事

---

### 旅程1：林远的觉醒（独立创作者 - 成功路径）

**人物锚定**：林远，35岁，全职网文作者，日更3000字，同时运营3部连载。现有工具是Notion + 多个AI对话窗口。

**开场：碎片化的困境**

周三凌晨，林远盯着屏幕，第三次收到读者私信："作者大大，女主第12章说从小怕水，怎么刚才那章突然会游泳了？"

他叹了口气，打开Notion翻找设定文档。三部连载，每部都有几十个角色，设定分散在不同页面。他已经记不清"怕水"这个设定是什么时候写的，也不确定后面哪些章节需要修改。

更让他沮丧的是AI助手——每次写作都要重新"提醒"它角色设定，它下次还是会忘。

**转折：一个承诺**

创作群里有人分享了一个帖子："AI终于能记住我的角色了。"

林远点进去，看到一个叫"AI有机体工作台"的产品。他半信半疑地注册，选择了「小说创作」模板。

界面很干净。系统引导他创建第一个角色卡——他输入"苏晓"，写下背景、性格、关键设定（包括"怕水"）。

**第一个"哇"（< 3分钟）**

他把昨天写的章节内容粘贴进去。几秒钟后，右侧面板亮起提示：

> *检测到你提到了「苏晓」，已自动关联到她的角色卡。*

林远愣了一下。他继续往下看，发现章节里提到苏晓"跳进河里救人"的那句话被标记了：

> *提醒：苏晓的设定中标注「怕水」。当前情节与设定可能存在冲突，是否需要添加剧情解释或更新设定？*

**林远的手停在鼠标上。**

"它……它真的知道苏晓怕水？"

他点击"更新设定"，添加了"克服怕水（本章后）"。系统立刻显示：

> *设定已更新。检测到以下章节引用了苏晓：第12章、第23章。其中涉及「怕水」描写的段落已标记，供您审查。*

这是林远用任何AI工具都没有体验过的——**它真的"认识"他的角色**。

**深度使用（第2周）**

林远开始把三部连载逐步迁移到系统里。

他最喜欢的是"变更传播"——上周他决定让一个配角从"忠诚"变成"叛变"，系统自动提示：

> *「张三」阵营变更会影响以下内容：*
> - *第34章对话（他当时还是忠诚的）*
> - *「青龙帮」势力卡（成员列表需更新）*
> *建议审查以上内容。*

他逐一确认，有的接受AI建议，有的自己微调。整个过程不到15分钟——以前这种检查要翻大半天。

**结局：新常态**

一个月后，林远再也没收到读者的"设定矛盾"投诉。

他在创作群发了一条消息，配图是系统的"有机系统蓝图"——角色、势力、事件像器官一样相互连接：

> "AI终于记住我的角色了。改了设定它会自动提醒我哪些章节需要调整。"

---

### 旅程2：林远的危机（独立创作者 - 边缘场景/错误恢复）

**开场：过度信任的代价**

使用系统三周后，林远习惯了"批量接受"AI的建议——效率太高了。

今天写高潮章节，他让AI助手润色一段打斗描写。AI返回了8条修改建议，他扫了一眼觉得没问题，点了"全部接受"。

**危机：错误传播**

第二天读者炸了："主角的剑明明是「寒冰剑」，怎么这章变成「烈焰剑」了？"

林远冷汗直流。他打开系统，发现问题：AI在润色时"智能地"把武器属性改了，而这个改动触发了关联更新——「寒冰剑」相关的描写、那个以"冰"为核心意象的伏笔，都被改成了"火"属性。

**转折：因果链追溯**

他点开「确认中心」，找到了"查看因果链"按钮。系统用树状图清晰展示了这次事故：

```
❌ AI错误修改「主角武器」属性: 冰 → 火 (源头)
   ├── 触发「寒冰剑描写」更新（3处）
   ├── 触发「冰系伏笔」更新（1处）
   └── 你点击了「全部接受」
```

他看到了"撤销这条因果链"的选项。

系统提示：

> *将撤销以下变更（按因果链回溯）：*
> - *「主角武器」属性恢复为"冰"*
> - *取消3处描写更新*
> - *取消伏笔更新*
>
> *注意：你今天新写的章节内容将保留，仅撤销武器相关改动。确认？*

林远点击确认。**5秒钟，一切恢复。**

**反思：建立新习惯**

他给「主角武器」加了标记：`#核心设定`，并把Policy调整为"严格模式"——以后任何修改都需要明确确认。

他也关掉了"批量接受"的默认设置，改用"逐条预览"。

在群里他发了一条：

> "AI搞砸了我的设定，但我5分钟就救回来了。工具再智能也要用脑子，但至少出错时有清晰的恢复路径。"

---

### 旅程3：张涛的有机体（技术开发者 - 成功路径）

**人物锚定**：张涛，28岁，创业公司技术负责人，现有工具是LangChain + 自研Agent框架。

**开场：框架的囚徒**

张涛的公司要做一个"情感陪伴AI"。用户的核心诉求是：**AI能记住我的故事、理解我的情绪、像一个真正的朋友。**

但现实很骨感。用LangChain搭的原型，每次对话都像和一个失忆症患者聊天。用户昨天说"我养了一只叫小黑的猫"，今天AI就问"你有宠物吗？"

他试过RAG、试过长上下文、试过Memory模块——都是缝缝补补。他开始怀疑：是不是AI就不可能"有状态"？

**发现：范式转换**

在GitHub上他看到一句话：

> *"AI本质无状态。是精密的上下文工程设计让AI有了状态。"*

这句话击中了他。他一直在用"增强记忆"的思路，但真正的问题不是记忆，是**状态设计**。

他注册了账号，选择"从空白开始"。

**构建：设计存在，而非编排动作**

张涛发现，这不是在"编程"，而是在"设计一个存在"。

他创建了几个核心"器官"（Context Unit）：
- **用户画像**：姓名、年龄、重要事件、性格标签
- **情感状态**：当前情绪、敏感话题、最近关注
- **记忆库**：重要对话片段、用户分享的生活细节

他用不同颜色的"边"连接它们：
- 蓝色（Reference）：AI回复时参考用户画像
- 紫色（Activation）：用户提到敏感话题时，触发情感状态更新

他配置了一个Agent负责「情感状态」维护，规则是：每次对话后根据内容更新情绪标签。

**第一个"哇"（测试）**

张涛开始测试：

*用户："今天又被老板骂了。"*

他看系统日志——Agent自动更新了情感状态：`当前情绪: 沮丧, 压力来源: 工作`。

AI的回复明显更加温柔："被骂的感觉确实很糟糕。愿意说说发生了什么吗？"

他继续测试。当用户提到"我家猫"时，AI自动关联到之前记录的"用户有一只叫小黑的猫"，回复里提到了小黑的名字。

**"它在'记住'用户。"**

**深度使用：导出为产品**

两周后，张涛完成了有机体设计。

他使用"自动化模式"导出——设置了触发条件（收到用户消息）、自动确认策略（低风险自动通过）、基础监控。

现在这个有机体可以独立运行，持续陪伴用户。

**结局：新的可能**

他把这套设计做成了公司的核心产品架构。在技术博客写道：

> "我们不再是在'编程'AI，而是在'设计'AI的存在。终于可以设计一个真正'活着'的AI，而不是一堆流程节点。"

---

### 旅程4：世界观组的协作（企业团队 - 成功路径）

**人物锚定**：游戏世界观组，5人团队——主策划陈刚（权威源）+ 3名策划（维护者）+ 1名AI协调员。现有工具是飞书文档 + 评审会议。

**开场：失控的设定**

周会上，陈刚问："精灵族的核心能力到底是什么？"

沉默。

策划A说："我那版是'擅长弓术'。"
策划B说："我改过了，是'擅长自然魔法'。"
策划C说："上周开会定的是'擅长治愈'啊。"

陈刚叹气。这种对话每周都在发生。五个人同时维护几百个种族、势力、地点的设定，飞书文档版本混乱，没人知道哪个是"官方版本"。

**转型：按责任分配变量**

技术负责人推荐了一个工具。陈刚决定试试。

第一步是配置权限——按职责分配变量责任：
- 策划A：人族相关（权威源）
- 策划B：妖族相关（权威源）
- 策划C：势力关系（权威源）
- 陈刚：全局设定（超级权限）
- AI协调员：一致性检查配置

每个人导入自己负责的内容。系统自动识别引用关系——"精灵族"被"第一次种族战争"引用，"龙脊山脉"被"矮人王国"引用……

**第一个"哇"（自动通知）**

策划B修改了"九尾狐族"的能力描述。

几秒钟后：

- **策划C**收到通知：*「你负责的「妖族联盟」引用了「九尾狐族」，该设定已被修改，请检查是否需要更新。」*
- **陈刚**收到通知：*「九尾狐族能力变更，受影响的关联设定：2个。需要您确认传播。」*

陈刚看到这一幕，笑了：**"终于不用在群里喊'我改了XX'了。"**

**冲突场景：同时编辑**

周五下午，策划A和策划B同时在编辑"人妖战争起因"——他们没有互相通知。

策划A改为："因为人族皇帝的贪婪"
策划B改为："因为妖族领地被侵占"

两人几乎同时点击保存。系统弹出冲突提示：

> *检测到编辑冲突*
>
> *「人妖战争·起因」被两人同时修改：*
> - *策划A: "人族皇帝的贪婪"*
> - *策划B: "妖族领地被侵占"*
>
> *请选择：[A版本] [B版本] [合并编辑] [提交给陈刚决定]*

两人在群里喊："你也在改这个？"

他们选择提交给陈刚。陈刚看到并排对比后，选择了"合并编辑"：

> "战争起因是复杂的——人族皇帝有领土野心，直接导火索是一次妖族领地被误伤事件。"

**结局：知识资产沉淀**

两个月后，团队做了对比：

| 指标         | 使用前 | 使用后 |
| ------------ | ------ | ------ |
| 每周设定争议 | 8-10次 | 1-2次  |
| 评审会时长   | 3小时  | 1小时  |
| 新人上手时间 | 2周    | 3天    |

陈刚在周会总结：**"每个人负责自己的模块，改动自动同步，再也不用开会对设定了。"**

---

### 旅程5：消费者视角（价值验证的下游证据）

**说明**：这不是平台用户的旅程，而是验证有机体输出价值的"下游证据"。

**场景A：小说读者**

读者小明追了林远的小说6个月。他在评论区写道：

> "追了这么久，发现作者真的很用心。前面铺垫的伏笔后面都回收了，角色性格前后一致，就连配角的行为逻辑都很连贯。"

林远截图发到朋友圈："这就是用这个工具的意义。"

**场景B：情感陪伴用户**

张涛的产品上线内测。一个用户反馈：

> "它怎么记得我上周说工作压力大？今天我说升职了，它说'看来坚持下来是值得的'。感觉它真的认识我。"

张涛把这条反馈截图给团队："这是我们验证的核心——用户感知到AI'有状态'。"

---

### 旅程6：张涛的集成调试（技术开发者 - 边缘场景）

> **版本要求：V1.5+**
> 覆盖导出有机体后的集成调试、API错误排查场景。

---

### 旅程7：林远的自助排查（独立创作者 - 支持/故障排除）

**开场：AI突然"变傻"了**

使用系统一个月后，林远发现AI助手突然变得很奇怪——每次写作时，AI给的建议都不着调，总是提到一些他根本没写过的角色名字。

"小青是谁？我的小说里根本没有这个角色！"

他以为是AI模型的问题，准备去群里抓狂。

**转折：发现诊断入口**

他在界面右上角发现了一个"系统状态"图标，点开后看到：

> *系统健康检查*
> - Context Units: 正常
> - 传播引擎: 正常
> - **Agent「引用识别」: 配置异常** ← 问题在这里！
> - Agent「一致性检查」: 正常

他点击「引用识别Agent」的警告标记，系统显示：

> *检测到配置异常：该Agent的规则中引用了不存在的Context Unit「官方角色库」。*
> *这可能导致Agent产生不相关的建议。*

"官方角色库？我从来没建过这个东西啊……"

**排查：溯源日志定位问题**

他点击"查看变更历史"，系统展示了这个Agent配置的溯源日志：

```
配置变更历史：

初始配置 (1月15日) - 模板默认
修改识别规则 (1月18日) - 你手动调整
规则覆盖 (1月22日) - 批量导入操作 ← 问题来源
```

林远想起来了1月22日他尝试导入一个网上找的"角色库模板"，那个模板里有个「官方角色库」的引用，导入时把Agent配置也覆盖了。

**解决：配置回滚**

系统提示：

> *可以将该Agent配置回滚到1月18日的版本（你的最后一次手动调整），或者恢复到模板默认配置。*
>
> *[回滚到1月18日] [恢复模板默认] [手动编辑]*

林远点击"回滚到1月18日"。

3秒后，Agent状态变回正常。他写了一段测试内容，AI建议恢复正常了。

**反思：建立新习惯**

林远学到了两件事：

1. **导入外部内容要检查影响** — 以后导入前先查看"将被覆盖的配置"
2. **系统状态面板很有用** — 以后遇到奇怪问题先看这里

他在笔记里写了一条：

> "工具的溯源功能比想象中有用。以前用其他工具出问题只能抽卡重来，这里能精确定位到哪一步出了问题。"

---

### Journey Requirements Summary

#### 能力需求映射

| 旅程               | 揭示的核心能力                         | 对应PRD Scope                         |
| ------------------ | -------------------------------------- | ------------------------------------- |
| 林远-成功路径      | 自动引用识别、变更传播提示、一致性检查 | MAV：Context Unit + 四种边 + 小说模板 |
| 林远-错误恢复      | 因果链可视化、因果链撤销、Policy配置   | MAV：因果链（基础版）+ 确认机制       |
| 张涛-成功路径      | 从空白构建、边类型配置、自动化模式导出 | MAV：三种运行模式 + 自动化配置        |
| 世界观组-成功+冲突 | 权限配置、变更通知、冲突检测与解决     | MAV：多人工作台（基础）               |
| 消费者视角         | 有机体输出质量验证                     | 成功指标：状态一致性满意度            |
| 张涛-集成调试      | API错误诊断、导出调试                  | V1.5+：开发者体验增强                 |
| 林远-自助排查      | 系统诊断、Agent配置审查、溯源日志、配置回滚 | MAV：Event Sourcing + 系统状态面板    |

#### 与PRD指标的对齐验证

| PRD指标              | 旅程中的验证点                                                   |
| -------------------- | ---------------------------------------------------------------- |
| 首次"哇"≤10分钟      | 林远：<3分钟（自动识别关联）；张涛：测试阶段（情感状态自动更新） |
| 第一个关联≤3分钟     | 林远旅程明确展示                                                 |
| AI建议采纳率≥60%     | 林远深度使用阶段展示                                             |
| 冲突解决≤5分钟       | 世界观组冲突场景展示                                             |
| 错误后继续使用率≥90% | 林远错误恢复旅程展示                                             |
| 问题平均诊断时间≤15分钟 | 林远自助排查旅程展示（从发现异常到解决）                           |

#### 版本边界对照

| 旅程               | MAV（0-3月） | V1.5（3-6月） | V2.0（6-12月） |
| ------------------ |-------------|---------------|----------------|
| 林远-成功路径      | ✅ 完整实现  | —             | —              |
| 林远-错误恢复      | ✅ 基础因果链 | ✅ 完整因果链可视化 | —         |
| 张涛-成功路径      | ✅ 完整实现  | —             | —              |
| 世界观组-成功+冲突 | ✅ 基础冲突检测 | ✅ 完整冲突处理UI | —        |
| 张涛-集成调试      | ❌          | ✅             | —              |
| 林远-自助排查      | ✅ 基础诊断  | ✅ 高级诊断     | —              |

---

## Domain-Specific Requirements

### 系统底线（不妥协点）

来自项目原始设计意图（总体想法.md），以下原则在任何情况下都不可妥协：

| 底线 | 说明 | 工程体现 |
|------|------|----------|
| **强制溯源** | 没有溯源不允许进入系统 | Event Sourcing 为唯一事实源 |
| **人类最终决策权** | 默认确认；四种模式全部开放且可配置到变量级 | 确认中心状态机 + 可审计事件 |
| **高度模块化** | 底层健硕、可替换、可扩展，长期不会被某一套方案绑死 | Adapter trait 隔离所有外部系统 |
| **可视化优先** | 复杂能力必须有对应 UI 支撑，不靠用户手写复杂配置才能用 | 三层体验架构 + UI约束选择 |
| **按需上下文** | 避免 token 爆炸，用依赖图 + PACK 编译 + 事件触发控制规模 | 传播引擎 + 查询范围限定 |
| **没有 MVP 心态** | 目标是最佳体验与效果；兜底来自灵活的底层与用户自定义 | MAV 不减架构骨架 |

### Compliance & Regulatory

#### 数据隐私策略

基于项目哲学"高度用户自定义"和"人类最终决策权"，我们采用**本地优先架构**：

| 模式 | 部署方式 | 数据存储 | 适用场景 |
|------|----------|----------|----------|
| **本地模式** | 单机运行 | 本地 SQLite/文件系统 | MAV 默认；个人创作者 |
| **P2P 协作** | 点对点同步 | 本地 + 加密同步 | V1.5+；小团队协作 |
| **企业自托管** | Docker/K8s 部署 | 企业自有服务器 | 企业版；数据合规要求 |
| **官方云服务** | SaaS | 平台托管（加密） | V2.0+；轻量用户 |

#### 内容审核策略

| 策略 | 说明 | 适用场景 |
|------|------|----------|
| **零审核** | 系统不介入内容审查 | 本地优先产品；默认策略 |
| **可选自检** | 官方模板可配置自检 Agent | 用户自愿使用 |
| **企业合规** | 企业部署时可对接外部审核 | 企业版插件 |

#### 分阶段审核策略细化 ✅ 已确认

借鉴 Dify 的 Moderation 模型实践和隐私优先原则，分阶段实施：

| 阶段 | 审核策略 | 说明 | 触发条件 |
|------|----------|------|----------|
| **MAV（本地优先）** | 完全零审核 | 用户完全拥有数据，平台不介入内容审查 | 本地运行（默认） |
| **V1.5（P2P 协作）** | 零审核 + 可选自检 Agent（发布前钩子） | 用户可配置自检规则，在模板分享前执行 | 分享模板前（用户自选） |
| **V2.0（云服务）** | 零审核（私有项目）+ 社区准则（模板分享） | 仅对公开分享的模板进行轻量检查 | 发布到模板市场 |

**风险分析：**
- 在提供云服务前，由于数据完全本地存储，平台内容风险可控
- 模板分享阶段引入社区准则确认机制，非强制审核但保留移除权利

**可审计机制（工程约束）：**
```yaml
content_policy:
  # 本地创作：完全无限制
  private_workspace: no_moderation

  # V1.5可选自检 Agent（发布前钩子）
  self_check_agent:
    enabled: true  # 用户自选
    trigger: "pre_share"  # 仅在分享前触发，非持续审查
    rules:
      - type: "sensitive_keywords"
        action: "warn"  # warn | block | confirm
      - type: "consistency_check"
        action: "confirm"
    # 自检结果写入事件（可审计）
    audit_event: "SelfCheckRun"

  # 模板分享：社区准则确认（可审计）
  template_sharing:
    require_guidelines_acceptance: true
    guidelines_version: "1.0"
    community_standards: "https://platform.com/guidelines"
    # 准则确认写入事件（可审计）
    audit_event: "GuidelinesAccepted"

  # 企业版：可对接外部审核
  enterprise:
    external_moderation_api: optional
    audit_log_retention: "7years"
```

**关键审计事件：**
| 事件类型 | 写入时机 | 内容 |
|----------|----------|------|
| `GuidelinesAccepted` | 用户确认社区准则时 | version, hash, timestamp |
| `SelfCheckRun` | 自检 Agent 执行后 | ruleset_version, result, warnings |

#### 知识产权

| 问题 | 策略 |
|------|------|
| 用户创作内容归属 | 完全归用户所有，平台不主张任何权利 |
| 模板分享协议 | 默认 MIT 协议，用户可自定义 |
| 基于模板创作的衍生作品 | 归创作者所有，遵循模板协议要求 |
| 官方模板知识产权 | 开源可自由使用，鼓励社区改进 |

### Technical Constraints

#### 本地优先架构约束

```yaml
核心约束:
  - 数据首先存储本地，云端同步为可选
  - 用户完全拥有数据，可随时导出完整项目
  - 离线状态下核心功能可用（除协作功能）
  - 云端同步必须端到端加密
```

#### 存储架构演进方案 ✅ 已确认

基于对 Graphiti（时序知识图谱框架）和 Memvid（Rust 单文件内存系统）的调研，采用分层存储架构：

```
┌─────────────────────────────────────────┐
│  应用层：Context Unit / Edge / Policy    │
├─────────────────────────────────────────┤
│  溯源层：Event Sourcing                  │
│  - MAV: SQLite WAL（append-only）        │
│  - V1.5+: 自研 ctxlog（借鉴 Memvid）     │
│    · 单文件结构                          │
│    · Embedded WAL + Checkpoint           │
│    · 可配置 Durability 等级              │
├─────────────────────────────────────────┤
│  图谱层：图投影（可替换）                 │
│  - MAV 默认: IndraDB（纯 Rust，工程可控） │
│  - 并行 PoC: Ladybug（能力评估中）        │
│  - 远期: FalkorDB（服务端）              │
├─────────────────────────────────────────┤
│  存储层：                                │
│  - 运行态：SQLite/ctxlog                 │
│  - 同步态：.ctxpkg 导出包（checkpoint+backup）│
│  - 传输：iCloud/Drive（MAV）→ P2P+CRDT（V1.5+）│
└─────────────────────────────────────────┘
```

---

##### MAV 阶段：SQLite WAL + .ctxpkg 导出包

**重要约束：SQLite WAL 不能直接同步**

SQLite 官方明确限制：**WAL 模式不适用于网络文件系统**。原因：
- WAL 需要共享内存（-shm 文件）协调多进程
- 网络文件系统无法提供 WAL 所需的共享内存一致性与文件锁语义

> 引用：SQLite 官方文档 - "WAL does not work over a network filesystem"

**工程推导**：iCloud/Drive 等跨设备同步系统同样无法保证 WAL 三文件（.db + .db-wal + .db-shm）的原子同步，因此我们不直接使用 WAL 文件作为跨设备同步单元。

**解决方案：导出包（.ctxpkg）作为同步形态**

```
工作项目（SQLite WAL）
    ↓
一致性快照（SQLite checkpoint + online backup API）
    ↓
.ctxpkg 导出包（稳定、可验证、可压缩）
    ↓
iCloud/Drive 同步
```

**导出包（.ctxpkg）结构**
```yaml
.ctxpkg/                    # ZIP 格式
├── manifest.json           # 版本、校验和、时间戳、schema_version
├── events/                 # SQLite checkpoint 后的数据
│   └── events.msgpack      # MessagePack 序列化
├── snapshot/               # 可选：图投影快照（加速启动）
│   └── graph.bin
├── attachments/            # 大文件（BLOB 分离存储）
│   └── ...
└── signature/              # 可选：签名验证
    └── ...
```

**生成流程（一致性保证）**
```rust
// 1. SQLite checkpoint（WAL → 主库）
// 2. Online backup API 生成一致性副本（不阻塞读取）
// 3. 序列化为 MessagePack
// 4. 计算校验和（BLAKE3）
// 5. 打包为 .ctxpkg
```

**Durability 等级（SQLite 阶段映射）**

| 等级 | SQLite 配置 | 语义 | 适用场景 |
|------|------------|------|----------|
| `FsyncEachAppend` | `PRAGMA synchronous=FULL` + 每事件 `fsync` | 最高可靠，吞吐最低 | 确认事件、关键变更 |
| `GroupCommit` | `PRAGMA synchronous=NORMAL` + 定时 checkpoint | 均衡（默认） | 一般事件流 |
| `NoFsync` | `PRAGMA synchronous=OFF` | 可能丢失最后 N 条 | 开发/测试环境 |

> SQLite PRAGMA 文档：`synchronous` 控制 WAL 模式下的 fsync 行为。FULL 会在每次 checkpoint 时额外 sync WAL，增强掉电安全性。

---

##### V1.5 阶段：自研 ctxlog（借鉴 Memvid）

**迁移触发条件（任一满足）**
1. 单项目事件量 > 100 万
2. 需要真正的单文件携带（.ctxpkg 解包即运行）
3. SQLite WAL 性能瓶颈
4. 需要跨存储后端适配（RocksDB/Postgres/S3）
5. 需要"可验证的二进制格式规范"（生态开放）

**ctxlog 设计目标（借鉴 Memvid，不硬抄）**
```
单文件结构（参考 Memvid MV2 格式）：
┌─────────────────────────────────────────┐
│ Header（4KB 对齐）                       │
│ - magic/version                         │
│ - 参数配置/TOC 指针                      │
│ - 校验策略声明                           │
├─────────────────────────────────────────┤
│ Embedded WAL 区域                        │
│ - RecordHeader: seq/len/checksum        │
│ - checksum: BLAKE3-256 (32 bytes)       │
│ - 循环缓冲区，checkpoint 后归档           │
├─────────────────────────────────────────┤
│ Data Segments（压缩后的事件数据）         │
├─────────────────────────────────────────┤
│ Footer/TOC（段目录 + 校验和）             │
└─────────────────────────────────────────┘
```

**借鉴 Memvid 的关键机制**
- **Checkpoint 协议**：WAL 区域满或定时触发，归档到 Data Segments（参考 Memvid `EmbeddedWal::record_checkpoint`）
- **崩溃恢复**：启动时扫描 WAL，回放未 checkpoint 的记录
- **Commit 语义**：`fsync` 策略可配置（与 Durability 等级对应）

**不硬抄的细节**
- Header 大小：页对齐（4KB）而非固定 48 字节
- 压缩算法：按事件类型可选（Zstd/LZ4）
- 索引结构：根据查询模式定制（Memvid 用时间/向量和全文，ctxlog 用事件类型/时间）

---

##### 图数据库：双 PoC 决策门（均衡型策略）

**MAV 默认：IndraDB（工程可控优先）**

理由：
- ✅ 纯 Rust 实现，无 FFI 集成成本
- ✅ 可嵌入，可 server（gRPC）
- ✅ Pluggable datastore（Memory/RocksDB/Postgres）
- ⚠️ License：MPL-2.0（需合规评估）
- ⚠️ 查询语言：无 Cypher（自有 DSL），需适配层
- ⚠️ 表达能力：属性过滤缺少 OR/AND 逻辑组合（见 indradb#228）
- ⚠️ Windows：非一等公民（见 indradb#125）

**并行 PoC：Ladybug（能力评估）**

理由：
- ✅ 完整 Cypher 支持
- ✅ 内置全文检索、向量索引（HNSW）
- ✅ 活跃维护（v0.14.2，2026-01）
- ⚠️ C++ 核心，FFI 集成成本
- ⚠️ 发布链路：部分绑定从 CI nightly 获取（供应链稳定性风险）
- ⚠️ Rename 后部分能力尚未完全就绪
- ⚠️ **WASM/NodeJS 支持尚未就绪**（v0.12.0 release notes 明确声明 "not working yet"）

**PoC 通过标准**

| 测试项 | 说明 | IndraDB | Ladybug |
|--------|------|---------|---------|
| 四类边传播查询 | 多跳下游遍历（Reference/Activation） | 待测 | 待测 |
| 影响范围子图导出 | 从 Unit A 导出受影响子图 | 待测 | 待测 |
| 快照/恢复一致性 | checkpoint → 清空 → 导入 → 校验 | 待测 | 待测 |
| 并发写入 | 1000 事件/秒 × 60 秒 | 待测 | 待测 |
| 跨平台打包 | Windows/macOS/Linux CI 通过 | 待测 | 待测 |
| License 合规 | MPL-2.0 分发策略 / MIT 简单性 | 需评估 | ✅ 简单 |

> **IndraDB 参考**：https://github.com/indradb/indradb（MPL-2.0）
> **Ladybug 参考**：https://github.com/LadybugDB/ladybug（活跃，但需验证发布链路）

**GraphStore Trait（保证可替换性）**
```rust
#[async_trait]
pub trait GraphStore: Send + Sync {
    // 基础 CRUD
    async fn create_vertex(&self, v: Vertex) -> Result<()>;
    async fn create_edge(&self, e: Edge) -> Result<()>;

    // 核心查询（项目必须）
    async fn neighbors(&self, unit_id: Uuid, edge_type: EdgeType, direction: Direction) -> Result<Vec<Vertex>>;
    async fn downstream(&self, unit_id: Uuid, edge_types: Vec<EdgeType>, max_depth: u32) -> Result<Vec<PropagationNode>>;
    async fn subgraph(&self, root: Uuid, filters: SubgraphFilters) -> Result<GraphView>;

    // 投影管理（checkpoint/恢复）
    async fn checkpoint(&self) -> Result<CheckpointId>;
    async fn restore(&self, checkpoint: CheckpointId) -> Result<()>;
}
```

**Datastore 安全建议（IndraDB）**
- 生产默认 RocksDB 或 Postgres
- Sled datastore 仅用于实验（已知升级需手动迁移，且有数据安全限制）

---

##### 技术债务风险评估

| 组件 | MAV 选择 | 风险点 | 预防措施 |
|------|----------|--------|----------|
| **EventStore** | SQLite WAL → ctxlog | 迁移时需事件转换工具 | 从第一天定义 `EventStore` trait，禁止业务层直接 SQL |
| **GraphStore** | IndraDB（默认）+ Ladybug（PoC） | IndraDB 查询表达能力限制；Ladybug FFI 成本 | `GraphStore` trait 隔离；PoC Gate 决定最终默认 |
| **Sync** | .ctxpkg 导出包 | 导出一致性、版本兼容 | checkpoint+backup API；manifest 版本化 |

**关键债务预防措施**

```rust
// 1. EventStore trait - 硬约束，仅 Maintenance 例外
pub trait EventStore: Send + Sync {
    async fn append(&self, event: Event) -> Result<Sequence>;
    async fn read_since(&self, seq: Sequence) -> Result<Vec<Event>>;
    // 禁止：业务层直接 SQL 查询
}

// Maintenance/Diagnostics 模块只读查询（白名单逃生门）
pub trait EventStoreDiagnostics {
    async fn export_raw(&self) -> Result<Vec<u8>>;  // 仅导出、调试
}

// 2. GraphStore trait - 隔离图数据库细节
pub trait GraphStore: Send + Sync {
    // 仅暴露业务必要查询，不暴露 Cypher/图查询语言
    async fn downstream(&self, ...) -> Result<Vec<PropagationNode>>;
}

// 3. StorageAdapter - 预留混合存储
pub enum StorageStrategy {
    EventSourced,      // 强制溯源（核心数据）
    SimplifiedCrud,    // 辅助数据（用户偏好、UI 状态）
    BatchAggregate,    // 批量导入模式
}
```

#### 反馈回路安全约束

> 详细约束规则见 Risk Mitigations → 设计时验证机制 → 反馈回路显式声明

核心原则：所有反馈回路必须显式声明安全参数（max_iterations、timeout_ms 等）

#### 四种确认模式完整配置

```yaml
确认策略配置:
  # 按 Tag 配置（默认策略）
  tag_policies:
    - tag: "#核心设定"
      confirmation: strict          # 严格模式：每个变更都需确认
      # 特点：最严格的确认级别，适用于关键业务数据

    - tag: "#重要变量"
      confirmation: confirm_required # 需确认模式
      # 行为：等同 strict，每个变更都需确认
      # 语义用途：用于明确标识"此变量必须由特定角色确认"
      # 示例：涉及多部门协作的 Unit，必须经部门负责人确认
      # 与 strict 的区别：confirm_required 强调"必须由特定 Authority Source 确认"
      # 而 strict 仅表示"需要确认"，不指定确认人

    - tag: "#常规内容"
      confirmation: batch_queue     # 批量模式：可批量接受建议
      # 适用：日常维护、低风险的批量操作

    - tag: "#草稿"
      confirmation: yolo           # YOLO 模式：自动接受，无需确认
      # 适用：快速迭代、实验性内容，用户明确选择信任 AI

  # 按 Unit 配置（覆盖 Tag 配置）
  unit_override: true

  # 混合维护者时的策略
  multi_maintainer_policy:
    primary: Agent-A      # 一级维护者：提出变更建议
    secondary: Agent-B    # 二级维护者：审查一级建议
    final_authority: user  # 最终决策权：人工确认
    flow: primary → secondary → final_authority
```

#### 多模型/多后端配置约束

支持按变量/卡片粒度配置不同模型和 API 后端，实现"质量/成本/速度"的自主控制。

**核心设计原则**

| 原则 | 说明 |
|------|------|
| 统一接口 | 所有 Provider 遵循 OpenAI-compatible API 标准 |
| 分层解耦 | ModelManager → Provider → Model 三层架构 |
| 水平扩展 | 通过配置文件即可添加新 Provider，无需修改核心代码 |
| 凭证隔离 | 支持 Provider 级和 Model 级两套凭证配置 |

**优先支持的 Coding 套餐（MAV 阶段）**

| 提供商 | 套餐类型 | Base URL | 特点 |
|--------|----------|----------|------|
| 智谱AI | GLM Coding Plan | `https://open.bigmodel.cn/api/paas/v4` | 性价比高，Claude Pro 套餐的1/3价格 |
| 月之暗面 | Kimi Coding | `https://api.moonshot.cn/v1` | 长上下文（200K） |
| MiniMax | MiniMax Coding | `https://api.minimaxi.com/v1` | 中文优化 |

**Provider 配置格式**

```yaml
providers:
  zhipu:  # 智谱 Coding 套餐（优先支持）
    name: "智谱AI"
    base_url: "https://open.bigmodel.cn/api/paas/v4"
    api_key: "${ZHIPU_API_KEY}"
    default_model: "glm-4.5-coding"
    timeout: 30000
    max_retries: 3
    models:
      - id: "glm-4.7-coding"
        context_window: 128000
        cost_per_1k_input: 0.002

  kimi:  # Kimi Coding 套餐（优先支持）
    name: "月之暗面"
    base_url: "https://api.moonshot.cn/v1"
    api_key: "${KIMI_API_KEY}"

  local:  # 本地模型（隐私优先场景）
    name: "本地模型"
    base_url: "http://localhost:11434/v1"
```

**按 Unit 配置模型策略**

```yaml
unit_model_config:
  - unit_tag: "#核心设定"
    provider: "zhipu"
    model: "glm-4.7-coding"
    temperature: 0.3

  - unit_tag: "#常规内容"
    provider: "zhipu"
    model: "glm-4.5-coding"

  - unit_tag: "#草稿"
    provider: "local"
    model: "qwen2.5-coder:7b"
```

**成本控制机制**

| 机制 | 说明 |
|------|------|
| Token 预算 | 按 Unit/Tag 设置月度 Token 上限 |
| 成本告警 | 达到预算 80% 时警告，100% 时自动降级 |
| 智能降级 | 主模型不可用/超预算时，自动切换到备用 Provider |
| 成本追踪 | 每个 Unit 的模型调用成本独立统计 |

**智能降级链配置**

```yaml
fallback_chain:
  - provider: zhipu
    model: glm-4.7-coding
  - provider: zhipu
    model: glm-4.5-coding
  - provider: local
    model: qwen2.5-coder
```

**参考实现**

借鉴以下开源项目的设计：
- **Cherry Studio** (CherryHQ/cherry-studio): Provider Registry、智能路由
- **Dify** (langgenius/dify): Model Runtime 三层架构、凭证管理

#### 模型配置降级提醒机制 ✅ 已确认

**架构：Dify 式三层 + Binding + 决策日志**

```
┌─────────────────────────────────────┐
│  ModelManager（全局配置）            │
│  - Provider 注册表                    │
│  - 全局默认模型                      │
│  - 成本追踪/告警                     │
├─────────────────────────────────────┤
│  Provider（服务商抽象）              │
│  - base_url/api_key                  │
│  - 限流/重试/超时策略                │
├─────────────────────────────────────┤
│  Model（具体模型）                   │
│  - 上下文长度/定价/能力标签           │
├─────────────────────────────────────┤
│  Binding（Unit/Agent 级覆盖）        │
│  - Agent-specific 模型绑定           │
│  - 降级链配置                        │
│  - 降级时用户提醒                    │
└─────────────────────────────────────┘
```

**Unit 级模型配置（与 Agent 绑定）**

```yaml
unit_model_config:
  - unit_tag: "#核心设定"
    agent_binding: "consistency-checker"
    provider: "zhipu"
    model: "glm-4.7-coding"
    temperature: 0.3

    # 降级链（MAV 实现同 Provider 降级；跨 Provider 后续增强）
    fallback_chain:
      - provider: "zhipu"
        model: "glm-4.5-coding"
        notify_user: true  # 静默通知：状态栏图标变化

      # MAV 后续阶段实现：
      # - provider: "local"
      #   model: "qwen2.5-coder:7b"
      #   notify_user: true
      #   quality_warning: "本地模型质量可能下降，建议复查输出"

  - unit_tag: "#常规内容"
    agent_binding: "reference-detector"
    provider: "zhipu"
    model: "glm-4.5-coding"
    fallback_chain: []  # 无降级，直接失败
```

**决策日志（强制事件，必须落盘）**

```rust
struct ModelDegradedEvent {
    timestamp: DateTime<Utc>,
    correlation_id: String,      // 链路追踪

    // 降级详情
    from: ModelRef,              // 智谱/glm-4.7-coding
    to: ModelRef,                // 智谱/glm-4.5-coding
    reason: DegradeReason,       // Timeout | RateLimit | Cost | Quality

    // 性能指标
    latency_ms: u64,
    cost_estimate: f64,

    // 上下文
    unit_id: Uuid,
    agent_id: String,
}
```

**用户提醒机制（MAV 阶段）**

| 降级类型 | 提醒方式 | 内容 |
|---------|---------|------|
| 同 Provider 降级 | 静默通知 | 状态栏图标变化，可点击查看详情 |
| 跨 Provider 降级 | 弹窗确认 | "已切换至备用模型，质量可能下降"（V1.5+） |
| 降级至本地模型 | 强制确认 | "已进入离线模式，部分功能受限"（V1.5+） |

**设计原则**
1. Unit 配置与 Agent 绑定是核心设计
2. **任何模型降级必须写入 EventStore**（否则审计成空话）
3. MAV 实现同 Provider 降级链闭环；跨 Provider 作为后续增强

**参考实现**
- **Cherry Studio** (CherryHQ/cherry-studio): Provider Registry、智能路由
- **Dify** (langgenius/dify): Model Runtime 三层架构、凭证管理

### Integration Requirements

#### 存储适配层接口

从第一天预留统一的存储适配接口：

```yaml
StorageAdapter:
  type: local_sqlite | p2p_crdt | self_hosted | cloud
  # 统一接口，支持不同阶段切换，无需重构代码

SyncAdapter:
  - offline:          # 单机模式（MAV 默认）
  - p2p:              # 点对点同步（V1.5+）
  - relay:            # 中继同步（V1.5+，用于 NAT 穿透）
  - centralized:      # 中心化同步（V2.0+ 官方云）
```

#### 协作技术选型

**选型决策：方案 C（三者都支持）**

| 阶段 | 技术方案 | 实现方式 | 适用场景 |
|------|----------|----------|----------|
| MAV | 本地 SQLite | 单机运行，可选加密云同步（iCloud/Google Drive） | 个人创作者 |
| V1.5 | P2P + CRDT | 点对点同步，端到端加密，无需中心服务器 | 小团队协作 |
| V2.0 | 官方云服务 | SaaS + 企业自托管选项 | 轻量用户/企业 |

#### 导出与分享机制

**三种导出/分享模式**：

| 模式 | 内容 | 用途 |
|------|------|------|
| **模板分享** | Unit类型定义、Agent规则、Policy配置 | 分享配置框架供他人使用 |
| **项目克隆** | 所有Unit + 完整历史 + 配置 | 团队新成员、完整备份 |
| **有机体导出** | 特定Snapshot + 运行配置 | 部署为自动化服务 |

**有机体配置包格式（概念版）**：

```yaml
organism_package:
  version: "1.0.0"
  schema_version: "2.0"

  metadata:
    name: "模板名称"
    author: "作者"
    description: "描述"
    license: "MIT"  # 可自定义

  config:
    unit_types: [...]      # Unit 类型定义
    edge_types: [...]      # 边类型配置
    agents: [...]          # Agent 规则
    template_units: [...]  # 预设 Unit

  sharing:
    allow_fork: true           # 允许基于此创建新模板
    allow_modification: true   # 允许修改后重新分享
    attribution_required: true # 需要保留原作者署名
```

**设计原则：灵活字段**

有机体配置包采用"开放字段"设计，避免定死字段限制后续扩展：

| 特性 | 说明 |
|------|------|
| 扩展字段 | config 下允许任意自定义字段，遵循命名空间规则（如 `x_custom_field`） |
| 版本兼容 | 新版本读取旧格式时，未知字段保留但不处理；旧版本读取新格式时，忽略未知字段 |
| 模板继承 | 支持基于现有模板创建新模板，可覆盖或扩展任意字段 |
| 字段校验 | 仅校验核心必填字段（version, schema_version, metadata），其余字段由模板自行定义规则 |

---

### 已确认/暂定（均衡型）决策总结

> 本节汇总 Step 5 所有技术选型决策，明确"已确认"与"暂定"状态，并记录 PoC Gate 与决策依据。

#### MAV 阶段（0-3 个月）

| 组件 | 决策 | 状态 | 关键依据 |
|------|------|------|----------|
| **内容审核** | MAV 完全零审核 | ✅ 已确认 | 本地优先/用户全权拥有数据 |
| **EventStore** | SQLite WAL（运行态）+ .ctxpkg 导出包（同步态） | ⚠️ 暂定 | SQLite 官方限制：WAL 不适用于网络文件系统；.ctxpkg 使用 checkpoint+backup API 生成一致性快照 |
| **GraphStore** | **IndraDB 默认**（工程可控）；Ladybug 并行 PoC（能力评估） | ⚠️ 暂定 | 均衡型选择：IndraDB 纯 Rust 降低 MAV 工程风险；Ladybug Cypher+检索能力待评估 |
| **协作同步** | 文件级同步（iCloud/Drive），同步单位为 .ctxpkg | ✅ 已确认 | 与 SQLite WAL 解耦，避免多文件同步风险 |
| **LLM Provider** | Dify 式三层 + 同 Provider 降级链 + 决策日志 | ✅ 已确认 | 降级必须写入 EventStore，保证可审计 |

#### V1.5 阶段（3-6 个月）

| 组件 | 决策 | 状态 | 迁移触发条件 |
|------|------|------|--------------|
| **EventStore** | 自研 ctxlog（借鉴 Memvid WAL/Checkpoint） | ⚠️ 暂定 | 事件量>100万 / 需真正单文件 / SQLite 瓶颈 |
| **协作同步** | Yrs（Yjs Rust port）+ libp2p | ⚠️ 暂定 | P2P 实时协作成为核心场景 |
| **图数据库** | PoC Gate 决定最终默认（IndraDB vs Ladybug） | ⚠️ 暂定 | 通过标准：四类边传播查询、影响范围导出、跨平台打包、License 合规 |

#### 关键 PoC Gate

**GraphStore PoC（MAV 阶段并行）**

| 测试项 | IndraDB | Ladybug | 权重 |
|--------|---------|---------|------|
| 四类边传播查询 | 待测 | 待测 | P0 |
| 影响范围子图导出 | 待测 | 待测 | P0 |
| 快照/恢复一致性 | 待测 | 待测 | P0 |
| 1000 事件/秒写入 | 待测 | 待测 | P1 |
| 跨平台打包成本 | 待测 | 待测 | P1 |
| License 合规 | MPL-2.0（需评估） | MIT（简单） | P2 |

**决策门**：MAV 验证期结束前（3 个月内）完成 PoC，通过标准全部达标者成为 V1.5 默认。

#### 技术债务预防检查清单

以下选择当前采用，但明确标为"暂定"，并给出替换触发信号：

| 组件 | MAV选择 | 状态 | 替换触发条件 | 备选方案 |
|------|---------|------|--------------|----------|
| **EventStore** | SQLite WAL | ⚠️ 暂定 | 事件量>100万 / 需真正单文件 / SQLite瓶颈 | 自研 ctxlog（借鉴Memvid） |
| **GraphStore** | Ladybug | ⚠️ 暂定 | 生态活跃度下降/关键功能缺口/FFI成本不可控 | IndraDB（默认）/ FalkorDB（远期） |
| **协作同步** | 文件级同步（iCloud/Drive） | ⚠️ 暂定 | 实时协作/多人工作台成为P0 | Yrs + libp2p |
| **LLM Provider** | Dify式三层 + Agent覆盖 | ⚠️ 暂定 | 出现更强的行业标准 | 待评估 |

**核心自研模块**（项目护城河，不替换）：
- [x] Context Unit 抽象与四种边类型系统
- [x] 变更传播引擎（Propagation Engine）
- [x] 确认中心（Confirmation Center）
- [x] 溯源可视化（Provenance Visualization）
- [x] `.ctxpkg` 数据格式规范

**已确认实现项**：
- [ ] `EventStore` trait 已定义，业务层禁止直接 SQL
- [ ] `GraphStore` trait 已定义，不暴露 Cypher/图查询语言到业务层
- [ ] `.ctxpkg` 导出流程：checkpoint → backup → 校验和 → 打包
- [ ] `ModelDegradedEvent` 写入 EventStore（审计）
- [ ] IndraDB MPL-2.0 License 分发策略文档（如需桌面客户端分发）

---

### Risk Mitigations

#### 设计时验证机制

通过神经网络设计约束预防运行时冲突：

**1. 单一 Maintainer 原则**

核心规则：每个 Unit 同一时间只有一个 Maintainer（人、Agent 或混合）

| 原则 | 说明 | 实现方式 |
|------|------|----------|
| 目的 | 从根本上避免传统"同时编辑"冲突 | 设计时责任分配，而非运行时锁 |
| 单一性 | 一个 Unit 不可被多个 Maintainer 并行维护 | 静态检查强制约束 |
| 变更 | 更换 Maintainer 需显式交接流程 | 记录交接事件，确保可追溯 |
| 例外 | 二次审查机制中多级 Maintainer | 串行执行，非并行（见 Authority Source vs Maintainer） |

**2. 传播方向确定性**
```
错误设计：                    正确设计：
角色A ──→ 势力 ←── 角色B     角色A ──┐
   ↑                    ↑           ├─→ 【聚合节点】──→ 势力
   └──── 同时修改 ──────┘      角色B ──┘
规则：多对一关系必须通过"聚合节点"
```

**3. 层级传播约束**
```
角色卡 ──→ 势力卡 ──→ 章节卡 ──→ 世界大纲
   │          │          │
   └──── 层级递增，不可随意跨级 ────┘
```

**4. 循环引用检测与保护**

虽然现实创作中一般不存在合理的循环依赖，但系统必须提供检测和保护机制：

| 场景 | 检测时机 | 处理策略 |
|------|----------|----------|
| 设计时静态检查 | 构建依赖图时 | 检测到循环 → 预警并给出重构建议 |
| 运行时保护 | 传播执行时 | 遇到未检测到的循环 → 自动暂停 + 标记待处理 |

重构建议示例：
```
检测到循环依赖：角色A → 角色B → 势力关系 → 角色A
建议：将"势力关系"拆分为独立 Unit，角色A/B 均引用该 Unit
```

**5. Maintainer 负载均衡检查**

| 检查项 | 阈值 | 处理策略 |
|--------|------|----------|
| 单一 Maintainer 负责的 Unit 数 | 默认 ≤50 | 超过时警告，建议拆分或增加 Maintainer |
| 单一 Unit 的 Maintainer 数量 | 必须 =1 | 多人/多 Agent 同时维护同一 Unit 时强制修复 |
| Maintainer 响应时间 | 可配置 | 超过阈值时自动触发备用 Maintainer 或转入待处理队列 |

**6. 反馈回路显式声明**

借鉴人体神经系统的反馈机制，所有反馈回路必须显式声明安全参数：

```yaml
反馈回路配置:
  type: negative_feedback | positive_feedback
  max_iterations: 10              # 【必须】最大迭代次数，防止无限循环
  timeout_ms: 5000                # 【必须】单次反馈超时，防止阻塞

  # 根据类型配置：
  convergence_threshold: 0.01     # 【负反馈必须】收敛阈值
  divergence_limit: 100           # 【正反馈可选】发散上限，防止级联过度

限制说明:
  - MAV 阶段：仅支持负反馈（如一致性自动修正）
  - V1.5+：支持正反馈（如剧情连锁反应）
  - 必须配置项不可省略，系统拒绝执行未配置安全参数的反馈回路
  - 达到 max_iterations 未收敛：强制终止，标记为"需人工检查"
  - 达到 timeout_ms：中断当前迭代，记录状态，等待下一次触发
```

**7. 设计时静态检查分级**

| 冲突类型 | 检测时机 | 处理策略 |
|----------|----------|----------|
| **高危（数据一致性风险）** | 设计时 | **强制修复**后才能运行 |
| **中危（性能瓶颈）** | 设计时 | **警告提示**，建议优化 |
| **低危（建议优化）** | 设计时/运行时 | **提示**，不阻断 |
| **运行时异常** | 传播过程中 | **自动暂停** + 进入确认队列 |

#### 运行时降级策略

| 场景 | 策略 |
|------|------|
| 检测到潜在冲突 | 自动暂停传播，进入确认队列等待人工裁决 |
| 反馈回路未收敛 | 达到 max_iterations 后强制终止，标记为"需人工检查" |
| 网络同步失败 | 本地继续运行，标记为"离线模式"，恢复后自动同步 |

#### 责任边界

| 场景 | 责任归属 | 系统行为 |
|------|----------|----------|
| 用户采纳 AI 建议后出现问题 | **用户承担责任** | 确认界面明确提示"你即将接受此变更" |
| AI 未经确认自动修改（YOLO模式） | **用户承担责任** | 模式切换需二次确认 |
| 模板 Agent 给出不合理建议 | **模板设计者责任** | 提供模板版本更新 + 用户可覆盖配置 |
| 传播机制错误 | **平台责任** | 紧急修复 + 数据恢复 |

#### Authority Source vs Maintainer 机制

```yaml
权限分离设计:
  Authority Source:
    - 定义：冲突时的最终决策人
    - 角色：人类/外部文档/系统/Agent
    - 权力：否决变更、强制落盘特定版本

  Maintainer:
    - 定义：负责提出变更建议
    - 角色：Agent/人类/规则
    - 权力：生成 ChangeSet、提交建议、无权强制落盘

  二次审查机制:
    - 适用：高价值/高风险 Unit
    - 流程：一级 Maintainer 提交 → 二级 Maintainer 审查 → Authority Source 确认
    - 特点：串行执行，前一级完成后才进入下一级
```

---

## Innovation & Novel Patterns

> ⚠️ **需要进一步讨论确认**：本节涉及的核心架构设计（统一溯源系统、分层图谱）需在技术方案评审阶段进一步细化

### Detected Innovation Areas

**1. 统一溯源架构：AI 有机体的神经系统与大脑**

强制溯源不是可选的审计功能，而是整个 AI 有机体的**神经系统 + 大脑**。

核心创新点：
- **系统级强制溯源**：让开发者能够像调试代码一样清晰 debug 自己设计的 AI agent 有机系统，追踪所有变更的完整因果链
- **AI 决策全记录**：每个负责基础变量/卡片的 AI agent 对变量的初始化、变更、提供变更建议（人机协同）、审查变更，都必须附带决策理由和判断依据
- **图谱深度融合**：图数据库不是展示层，而是 AI 的"工作记忆"

**2. 用户可定义的图谱系统**

将图谱作为核心功能提供给用户：

- **规则定义**：用户可以定义图谱的创建规则和维护规则
- **AI 维护委托**：用户可以指派特定 AI agent 负责特定图谱的维护
- **权限精细控制**：可以开放不同图谱给不同 AI agent 的不同权限（查询/维护/管理）

示例场景：
> 小说创作者创建"人物关系图谱"，定义关系记录规则，指派"角色管理 Agent"负责维护。当 Agent 更新角色设定时，自动按规则同步更新人物关系图谱。其他 Agent 可以自由查询该图谱辅助创作决策。

**3. Claude Code 式的图谱查询模式**

- 不依赖向量搜索，而是用**工具调用**模式
- AI agent 通过工具查询图谱："苏晓有哪些社会关系？"
- AI agent 通过工具维护图谱："添加苏晓与李明的朋友关系"
- 让图谱操作变得灵活可编程

**4. 分层图谱设计：图谱中的图谱（Graph within Graph）**

为在庞大的溯源系统中保持清晰可维护，采用"分层图谱"架构：

```
底层溯源系统（统一 Event Sourcing）- 唯一事实源
├─ Agent 决策子图（微观层面：决策理由、判断依据、变更建议、审查意见）
├─ 用户业务子图（业务层面：人物关系、势力网络、世界观设定）
└─ 系统配置子图（元数据层：Unit 类型、边类型、Policy 规则）
```

**设计原则：**
- 底层溯源系统只关心"发生了什么"（事件流）
- 小图谱关心"关系是什么"（语义网络）
- 两者通过 Event ID / Unit ID 关联

**三类子图谱：**

| 子图谱类型 | 所属层面 | 内容 | 使用方 |
|-----------|---------|------|--------|
| Agent 决策子图 | 微观层面 | 决策理由、判断依据、变更建议、审查意见 | 开发者调试、AI 自省 |
| 用户业务子图 | 业务层面 | 人物关系、势力网络、世界观设定、自定义业务关系 | 用户、AI agent 查询/维护 |
| 系统配置子图 | 元数据层 | Unit 类型、边类型、Policy 规则、权限配置 | 系统、开发者 |

**权限模型（统一系统，多种权限）：**

| 使用场景 | 权限分配 | 功能 |
|---------|---------|------|
| 开发者监控 AI agent 有机体整体运转 | 全量读取 + 因果链回溯 | 调试、监控、优化 |
| AI agent 维护图谱 | 写入决策 + 图谱更新 | 根据变量变更同步维护关系图 |
| AI agent 查询图谱 | 读取查询权限 | 灵活查询关系，辅助决策 |
| 系统内部 | 自动维护图谱一致性 | 事件触发图谱更新 |

**5. 技术灵感来源**

**OASIS 项目借鉴：**
- AgentGraph 双后端设计（igraph/Neo4j）→ 我们的 GraphStore trait 设计
- Event Trace 表记录所有动作 → 我们的 Event Sourcing 溯源系统
- Channel 通信解耦 Agent 与 Platform → 我们的 Context Unit 间通信
- Semaphore 限流控制并发 → 大规模传播时的背压机制

**Rust Event Sourcing 生态参考：**
- cqrs-es crate：轻量级 CQRS/Event Sourcing 框架
- event_sourcing.rs：事件溯源框架
- esrs：CQRS/Event Sourcing 实现参考

### Market Context & Competitive Landscape

| 维度 | 本项目 | 现有方案 (Dify/LangChain/OASIS) |
|------|--------|--------------------------------|
| 核心范式 | AI 有机体（设计存在） | 编排动作（工作流/流程图） |
| 状态管理 | 系统化上下文工程，强制溯源作为唯一事实源 | prompt + workflow，本质无状态；可选审计日志 |
| 图谱功能 | 用户可定义 + AI 可维护 + 深度融合；分层图谱设计 | 仅作为展示或社交关系图；无 AI 维护能力 |
| AI 可解释性 | 决策理由强制记录，完整决策链可追溯 | 无结构化决策记录 |
| 调试能力 | 系统级 debug 有机体运转，因果链可视化 | 单 Agent 日志级别；无传播链追踪 |
| 人机协同 | 围绕项目状态共同管理，AI 主动发现关联 | 人发指令，AI 执行 |

### Validation Approach

**技术验证指标：**

| 指标 | 定义 | 目标 |
|------|------|------|
| 溯源系统性能 | 单项目 10万+ 事件的读写延迟 | <100ms |
| 图谱查询响应 | 复杂关系查询延迟 | <500ms |
| AI 决策记录完整性 | 所有变更操作附带决策依据的比例 | 100% |
| 子图谱查询效率 | 按子图过滤查询 vs 全量扫描的性能提升 | 10x+ |

**用户验证指标：**

| 指标 | 定义 | 目标 |
|------|------|------|
| 开发者调试效率 | 定位问题时间 vs 传统方式 | 从小时级降至分钟级 |
| AI 建议可信度 | 用户采纳率（有决策依据 vs 无依据） | ≥70% |
| 图谱维护满意度 | 用户对 AI 自动维护图谱的满意度 | ≥4.0/5 |

### Risk Mitigation

| 风险 | 说明 | 缓解策略 |
|------|------|---------|
| 溯源系统性能瓶颈 | 事件量爆炸导致读写延迟增加 | 分层存储：热数据 SQLite + 温数据压缩 + 冷数据归档；增量投影更新 |
| 图谱规模爆炸 | 子图数量过多导致管理复杂 | 按项目分片；按需加载子图；子图生命周期管理 |
| 子图边界模糊 | 一个事件可能属于多个子图 | 定义清晰的"所有权"规则：事件只能有一个"主属"子图，其他子图通过引用关联 |
| 跨子图查询复杂 | 需要查询跨子图的关联关系 | 建立索引：事件同时包含 namespace + affected_graphs 字段 |
| AI 维护图谱出错 | AI 自动维护图谱可能导致错误 | 变更确认机制；高风险操作人工审核；完整回滚能力 |
| 用户定义规则冲突 | 多个用户定义的规则可能冲突 | 设计时静态检查；运行时冲突检测；Authority Source 最终裁决 |

### Architecture Decision Notes

> ⚠️ **需要进一步讨论确认**
>
> 以下架构决策基于高级引导方法（Architecture Decision Records、Graph of Thoughts、Tree of Thoughts）的深入分析形成初步结论，但需在技术方案评审阶段进一步确认：

#### ADR-1: 分层图谱实现方案（待定）

**初步结论**: MAV 阶段采用命名空间隔离，V1.5+ 评估图投影

**分析理由**:
- 命名空间开发成本低，便于快速验证概念
- 子图边界不清晰时，物理隔离减少错误
- 便于后续无缝迁移（仅查询方式变化）

**触发迁移的条件**:
- 跨子图查询占比 > 30%
- 命名空间过滤开销成为瓶颈
- 需要复杂图算法（最短路径、社区发现）

#### ADR-2: 图数据库选型（待定）

**初步结论**: MAV 阶段使用 IndraDB，V1 阶段评估 Neo4j

**评估矩阵**:

| 维度 | IndraDB | Neo4j |
|------|---------|-------|
| 技术契合度 | ★★★ Rust 原生 | ★★☆ 需桥接 |
| 生态成熟度 | ★★☆ 新兴 | ★★★ 成熟 |
| 许可成本 | 低 | 高 |
| 团队学习成本 | 低 | 中 |

**决策理由**: 技术栈契合优先，MAV 阶段快速验证；性能瓶颈时迁移到 Neo4j

#### ADR-3: 溯源粒度（待定）

**初步结论**: MAV 采用中粒度（用户操作 + AI 决策理由）

**对比分析**:

| 粒度 | 内容 | 适用阶段 | 优缺点 |
|------|------|----------|--------|
| 粗粒度 | 仅最终状态变更 | MVP | 简单性能好，但无法解释 |
| 中粒度 | 用户操作 + AI 决策 | MAV | 平衡可追溯与性能 |
| 细粒度 | 包含推理中间步骤 | V2+ | 最完整，但存储爆炸 |

#### ADR-4: 子图划分策略（待定）

**初步结论**: 采用"三层混合"策略

```
第一层：按项目划分（数据隔离）
第二层：按角色划分（权限控制：Agent/用户/系统）
第三层：按领域划分（业务语义：人物/世界观/势力）
```

**Graph of Thoughts 洞察**:
统一溯源架构具有"自我相似性"——溯源系统本身也可以用 Event Sourcing 记录其对图谱的维护操作，形成递归结构。

**统一溯源思维网络**:

```
                              ┌──────────────┐
                              │   强制溯源    │
                              │ Event Source │
                              └──────┬───────┘
                                     │
            ┌────────────────────────┼────────────────────────┐
            │                        │                        │
            ▼                        ▼                        ▼
    ┌───────────────┐      ┌─────────────────┐      ┌───────────────┐
    │  神经系统隐喻  │      │   大脑隐喻       │      │  记忆系统隐喻  │
    │  (变更传播)   │◄────►│  (决策记录)     │◄────►│  (图谱查询)   │
    └───────┬───────┘      └────────┬────────┘      └───────┬───────┘
            │                       │                       │
            │           ┌───────────┴───────────┐           │
            │           │                       │           │
            ▼           ▼                       ▼           ▼
    ┌───────────────┐  ┌───────────────┐  ┌───────────────┐
    │  Agent 决策子图 │  │ 用户业务子图   │  │ 系统配置子图   │
    │  (微观层面)    │  │ (业务层面)    │  │ (元数据层)    │
    └───────┬───────┘  └───────┬───────┘  └───────┬───────┘
            │                  │                  │
            │    ┌─────────────┼─────────────┐    │
            └────►             │             ◄────┘
                         ┌─────┴─────┐
                         │  涌现特性  │
                         └───────────┘
                               │
        ┌──────────────────────┼──────────────────────┐
        │                      │                      │
        ▼                      ▼                      ▼
  ┌─────────────┐      ┌─────────────┐      ┌─────────────┐
  │ AI 自省能力  │      │  自动一致性  │      │  因果可视化  │
  │ (自我解释)   │      │  (传播验证)  │      │  (调试神器)  │
  └─────────────┘      └─────────────┘      └─────────────┘
```

#### ADR-5: 存储选型确认（待定）

**初步结论**:
- MAV: SQLite WAL 模式（目标：<500ms @ 1万事件）
- V1: 评估 ctxlog（目标：<200ms @ 10万事件）
- V2: 考虑分布式方案（目标：<100ms @ 100万事件）

**触发迁移的具体数值**（需 PoC 验证）:
- SQLite → ctxlog: 读写延迟 > 500ms 持续 1 周
- ctxlog → 分布式: 事件量 > 100万 且查询延迟 > 200ms

#### ADR-6: AI 维护权限模型（待定）

**初步结论**: 分层信任模型

**权限分级**:
- 高风险变更（删除关系、修改核心设定）→ 必须人工审核
- 低风险变更（添加非关键属性）→ 可自动执行
- 建立"信任分数": AI 准确率高的图谱可提升自动权限

**分层可见性**:
- L1 设计师: 看到完整因果链（调试用）
- L2 运营者: 只看到业务层面变更（人物关系、设定变更）
- AI Agent: 自动消费底层事件，无需人工干预

#### ADR-7: 权限模型细节 & 跨子图查询（待定）

**初步结论**:
- 权限模型: 基于"命名空间 + 角色"的 ACL 模型
- 跨子图事件: 采用"单主属 + 多引用"机制
- 索引设计: 事件包含 namespace + affected_graphs 字段

---

### Risk Mitigation 补充

基于 Tree of Thoughts 分析识别的额外风险：

| 风险 | 缓解策略 | 监控指标 |
|------|----------|----------|
| IndraDB 生态不成熟 | 封装 GraphStore trait，保留切换能力 | 社区活跃度、issue 响应时间 |
| 迁移到 Neo4j 成本高 | 早期设计兼容性层，避免深度特性绑定 | 抽象层覆盖率 |
| 溯源粒度选择错误 | 支持动态调整，从粗到细逐步增加 | 用户调试满意度 |
| 三层子图划分复杂 | 提供默认模板，渐进式暴露高级功能 | 配置错误率 |
