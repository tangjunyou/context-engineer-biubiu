---
stepsCompleted: ['step-01-init', 'step-01b-continue', 'step-02-discovery', 'step-03-success', 'step-04-journeys', 'step-05-domain']
inputDocuments:
  - '_bmad-output/planning-artifacts/product-brief-AI 上下文工程可视化项目-2026-01-29.md'
  - '_bmad-output/analysis/brainstorming-session-2026-01-22.md'
  - '总体想法.md'
documentCounts:
  briefs: 1
  research: 0
  brainstorming: 1
  projectDocs: 1
workflowType: 'prd'
classification:
  projectType: 'Platform + Developer Tool + Creative Tool'
  domain: 'AI Infrastructure + Creative Tools'
  complexity: 'Very High'
  projectContext: 'greenfield'
  innovationPositioning: 'New Paradigm: AI Organism'
  technicalCharacteristics: 'State-Intensive System'
---

# Product Requirements Document - AI 上下文工程可视化项目

**Author:** 耶稣
**Date:** 2026-01-29

## Success Criteria

> **核心成功验证问题：** 用户是否真的感知到"AI有状态"带来的价值差异？
>
> 本项目的成功不是功能堆砌或用户数增长，而是验证一个根本命题：**通过上下文工程赋予AI状态，能让AI真正"活"起来，并被用户清晰感知。**

### 指标与愿景对齐验证

| 核心愿景 | 验证指标 | 逻辑 |
|----------|----------|------|
| "让AI有状态" | 状态感知率、跨会话记忆验证率 | 如果用户感知不到状态，核心价值失败 |
| "设计AI的存在" | 有效关联变量数、语义化命名率 | 如果用户不在"设计有机体"，定位失败 |
| "AI活起来了" | 首次"哇"时刻时间、主动关联发起率 | 如果用户不惊艳，MAV定位失败 |
| "高度用户自定义" | 模板修改率、自定义配置比例、配置存活率 | 如果只用默认，用户创造自由度未被发挥 |

### User Success

#### AI"活性"验证指标（核心差异化验证）

| 指标 | 定义 | 目标 | 为什么重要 |
|------|------|------|------------|
| 主动关联发起率 | AI主动发现并提示的关联/问题，占所有关联提示的比例 | ≥30% | 这才是"活着"的证明，而非"被动响应" |
| 跨会话记忆验证率 | 用户在新会话中测试，AI仍能正确引用历史设定的比例 | ≥90% | 真正的"有状态"意味着跨会话持续 |
| 一致性零矛盾天数 | AI建议与项目历史无逻辑矛盾的连续天数 | 连续7天 | 这是"连贯性"的直接证明 |
| 状态感知率 | 用户修改变量后，触发关联提示的比例 | ≥80% | 验证"变更传播"机制生效 |
| 首次"哇"时刻时间 | 用户从上手到体验第一个自动关联的时间 | ≤10分钟 | 验证上手体验达标（MAV定位） |

#### 用户行为成功指标

| 指标 | 定义 | 目标 | 为什么重要 |
|------|------|------|------------|
| 有效关联变量数 | 被至少3条边连接的Context Unit数量 | ≥20个/项目 | 用户在认真构建"神经系统" |
| AI建议采纳后未修改率 | 用户接受AI建议后未再修改的比例 | ≥70% | 采纳且不改 = AI建议真正有价值 |
| 7日项目活跃率 | 7日内项目有任何变更的比例 | ≥40% | 产品有持续价值 |
| 语义化命名率 | Context Unit使用语义名称而非默认名称的比例 | ≥80% | 用户用"器官"思维而非"节点"思维 |

#### 分用户类型成功指标

| 用户类型 | 核心成功指标 | 目标 |
|----------|--------------|------|
| 独立创作者 | 长篇项目持续率（10章→30章） | ≥30% |
| 技术开发者 | 成功导出可运行有机体的用户比例 | ≥50% |
| 企业团队 | 多人协作项目持续活跃≥30天的比例 | ≥60% |

#### 体验层级进阶指标

| 指标 | 定义 | 目标 |
|------|------|------|
| L1→L2进阶率 | 使用协作功能的用户比例 | ≥60% |
| L2→L3进阶率 | 进入高级设置的用户比例 | ≥20% |
| 各层级满意度 | 每层体验评分 | ≥4.0/5 |

#### 高度用户自定义验证指标

| 指标 | 定义 | 目标 | 为什么重要 |
|------|------|------|------------|
| 模板修改率 | 用户对官方模板进行自定义调整的比例 | ≥30% | 用户在发挥创造力 |
| 自定义配置比例 | 用户创建的原创变量/规则占比 | ≥20% | 平台的自定义价值被使用 |
| 用户原创模板数 | 用户分享的原创模板数量 | 持续增长 | 生态健康度 |
| 自定义配置7日存活率 | 用户自定义的规则/Policy在7天后仍在使用的比例 | ≥70% | 自定义功能真正有效 |

### Business Success

#### 阶段性业务目标

| 阶段 | 时间 | 核心目标 | 关键指标 |
|------|------|----------|----------|
| MAV验证期 | 0-3个月 | 验证核心价值主张 | 种子用户留存≥50%，NPS≥40 |
| 产品市场契合 | 3-6个月 | 确认PMF | 自然增长占比≥30%，付费转化≥5% |
| 规模化增长 | 6-12个月 | 扩大用户基础 | 月活用户≥10,000 |
| 生态建设 | 12个月+ | 建立模板生态 | 社区模板≥100个 |

#### 竞争力验证指标

| 指标 | 定义 | 目标 |
|------|------|------|
| 同任务效率提升比 | 与Dify完成同样任务的步骤数/时间对比 | ≥50%提升 |
| NPS中提及"AI有状态"比例 | 推荐原因中提到核心价值的比例 | ≥50% |

#### 商业模式指标（如适用）

| 指标 | 定义 | 目标 |
|------|------|------|
| 免费→付费转化率 | 试用用户转付费的比例 | ≥5% |
| 用户生命周期价值(LTV) | 付费用户平均贡献收入 | 取决于定价策略 |
| 客户获取成本(CAC) | 获取一个付费用户的成本 | LTV/CAC ≥ 3 |

### Technical Success

#### 性能指标

| 指标 | 定义 | 目标 |
|------|------|------|
| 1000 Units传播延迟 | 中等规模项目的传播响应时间 | ≤500ms |
| 5000 Units项目加载时间 | 大型项目的打开时间 | ≤5秒 |
| 增量传播率 | 能增量计算而非全量重算的传播比例 | ≥90% |
| Event写入吞吐 | 支撑实时协作的写入能力 | ≥1000/s |
| API可用性 | 系统正常运行时间比例 | ≥99.5% |

#### 开发者体验指标

| 指标 | 定义 | 目标 |
|------|------|------|
| 错误信息可操作率 | 错误信息包含解决建议的比例 | ≥90% |
| API文档覆盖率 | API接口有完整文档的比例 | 100% |
| 问题平均诊断时间 | 开发者定位问题的平均时间 | ≤15分钟 |
| 导出有机体冷启动时间 | 导出后首次启动时间 | ≤3秒 |

#### 协作成功指标

| 指标 | 定义 | 目标 |
|------|------|------|
| 冲突解决平均时间 | 两人同时修改同一设定的解决时间 | ≤5分钟 |
| 关键变更通知确认率 | 相关人员确认收到重要变更通知的比例 | ≥95% |
| 通知聚合率 | 相关变更合并通知而非逐条的比例 | ≥70% |

### Measurable Outcomes

#### 核心KPI仪表盘（按优先级）

| 优先级 | KPI | 测量方式 | 目标 | 频率 |
|--------|-----|----------|------|------|
| **P0** | 首次"哇"时刻转化率 | 用户首次触发自动关联的比例 | ≥80% | 日 |
| **P0** | 7日项目活跃率 | 7天后仍有项目活动的用户比例 | ≥40% | 周 |
| **P1** | 项目完成率 | 用户创建的项目达到"可用状态"的比例 | ≥30% | 周 |
| **P1** | AI建议采纳后未修改率 | 用户接受变更建议后未再修改的比例 | ≥70% | 周 |
| **P2** | 模板使用率 | 使用官方模板vs从空白开始的比例 | ≥70%使用模板 | 月 |
| **P2** | 社区贡献率 | 用户分享模板/配置的比例 | ≥5% | 月 |

#### 领先指标（预测成功）

| 指标 | 定义 | 目标 |
|------|------|------|
| 模板引导完成率 | 用户完成引导流程的比例 | ≥80% |
| 第一个关联建立时间 | 从开始到建立首个关联的时间 | ≤3分钟 |
| 日活Context Unit数/项目 | 项目的"心跳"指标 | ≥5个 |

#### 关联指标（体验链路验证）

| 指标 | 定义 | 目标 |
|------|------|------|
| 因延迟导致操作放弃率 | 用户因等待而放弃操作的比例 | ≤5% |
| 错误后继续使用率 | 用户遇错后没有离开的比例 | ≥90% |
| 冲突后内容一致性检查通过率 | 解决冲突后内容仍保持一致的比例 | ≥95% |

#### 反指标（避免虚荣追求）

| 不追求 | 为什么 | 替代关注 |
|--------|--------|----------|
| 注册用户总数 | 虚荣指标，不代表价值 | 活跃用户数、留存率 |
| 页面访问量 | 不代表用户获得价值 | 核心功能使用率 |
| AI调用次数 | 多不代表好 | AI建议采纳率、满意度 |
| 功能数量 | 堆功能不是目标 | 核心功能完成率 |

## Product Scope

### MVP - Minimum Viable Product

**定位：MAV（最小惊艳版本）** — 用户在10分钟内体验到"哇"，核心价值主张被清晰感知。

**核心交付：**
- 统一抽象：Context Unit + 四种边类型 + Tag + Policy
- 三种运行模式：单人工作台（完整）+ 多人工作台（基础）+ 自动化模式（配置）
- Event Sourcing 源系统 + 确认机制
- 小说创作官方模板（8种预设类型 + 4个预设Agent）
- 完整UI/UX（三层体验架构 + 有机系统蓝图）

**成功验证标准：**
- 首次"哇"时刻转化率 ≥80%
- 7日项目活跃率 ≥40%
- NPS ≥40

### Growth Features (Post-MVP)

**V1.5 扩展：**
- 完整因果链可视化与操作
- 复杂冲突处理与多级审批流程
- AI设定矛盾主动检测
- 跨分支查询能力

**V2.0 愿景：**
- 两阶段回溯重构
- 专业运维仪表盘与高级监控
- 多方协商确认机制
- 完整开放生态

### Vision (Future)

**长期愿景（2-3年）：**
- 成为AI有机体构建的行业标准平台
- 覆盖小说创作、游戏世界构建、企业知识管理等多场景
- 建立活跃的模板生态和开发者社区
- 让"AI有机体"成为新的产品范式

## User Journeys

### 设计原则

1. **人物保持一致**：严格使用Product Brief定义的用户画像细节
2. **时间指标对齐**：首次"哇"≤10分钟，第一个关联≤3分钟
3. **能力边界清晰**：仅涉及MAV范围能力，V1.5/V2.0功能明确标注"未来"
4. **骨架来自文档**：以Product Brief已有的旅程框架为基础深化叙事

---

### 旅程1：林远的觉醒（独立创作者 - 成功路径）

**人物锚定**：林远，35岁，全职网文作者，日更3000字，同时运营3部连载。现有工具是Notion + 多个AI对话窗口。

**开场：碎片化的困境**

周三凌晨，林远盯着屏幕，第三次收到读者私信："作者大大，女主第12章说从小怕水，怎么刚才那章突然会游泳了？"

他叹了口气，打开Notion翻找设定文档。三部连载，每部都有几十个角色，设定分散在不同页面。他已经记不清"怕水"这个设定是什么时候写的，也不确定后面哪些章节需要修改。

更让他沮丧的是AI助手——每次写作都要重新"提醒"它角色设定，它下次还是会忘。

**转折：一个承诺**

创作群里有人分享了一个帖子："AI终于能记住我的角色了。"

林远点进去，看到一个叫"AI有机体工作台"的产品。他半信半疑地注册，选择了「小说创作」模板。

界面很干净。系统引导他创建第一个角色卡——他输入"苏晓"，写下背景、性格、关键设定（包括"怕水"）。

**第一个"哇"（< 3分钟）**

他把昨天写的章节内容粘贴进去。几秒钟后，右侧面板亮起提示：

> *检测到你提到了「苏晓」，已自动关联到她的角色卡。*

林远愣了一下。他继续往下看，发现章节里提到苏晓"跳进河里救人"的那句话被标记了：

> *提醒：苏晓的设定中标注「怕水」。当前情节与设定可能存在冲突，是否需要添加剧情解释或更新设定？*

**林远的手停在鼠标上。**

"它……它真的知道苏晓怕水？"

他点击"更新设定"，添加了"克服怕水（本章后）"。系统立刻显示：

> *设定已更新。检测到以下章节引用了苏晓：第12章、第23章。其中涉及「怕水」描写的段落已标记，供您审查。*

这是林远用任何AI工具都没有体验过的——**它真的"认识"他的角色**。

**深度使用（第2周）**

林远开始把三部连载逐步迁移到系统里。

他最喜欢的是"变更传播"——上周他决定让一个配角从"忠诚"变成"叛变"，系统自动提示：

> *「张三」阵营变更会影响以下内容：*
> - *第34章对话（他当时还是忠诚的）*
> - *「青龙帮」势力卡（成员列表需更新）*
> *建议审查以上内容。*

他逐一确认，有的接受AI建议，有的自己微调。整个过程不到15分钟——以前这种检查要翻大半天。

**结局：新常态**

一个月后，林远再也没收到读者的"设定矛盾"投诉。

他在创作群发了一条消息，配图是系统的"有机系统蓝图"——角色、势力、事件像器官一样相互连接：

> "AI终于记住我的角色了。改了设定它会自动提醒我哪些章节需要调整。"

---

### 旅程2：林远的危机（独立创作者 - 边缘场景/错误恢复）

**开场：过度信任的代价**

使用系统三周后，林远习惯了"批量接受"AI的建议——效率太高了。

今天写高潮章节，他让AI助手润色一段打斗描写。AI返回了8条修改建议，他扫了一眼觉得没问题，点了"全部接受"。

**危机：错误传播**

第二天读者炸了："主角的剑明明是「寒冰剑」，怎么这章变成「烈焰剑」了？"

林远冷汗直流。他打开系统，发现问题：AI在润色时"智能地"把武器属性改了，而这个改动触发了关联更新——「寒冰剑」相关的描写、那个以"冰"为核心意象的伏笔，都被改成了"火"属性。

**转折：因果链追溯**

他点开「确认中心」，找到了"查看因果链"按钮。系统用树状图清晰展示了这次事故：

```
❌ AI错误修改「主角武器」属性: 冰 → 火 (源头)
   ├── 触发「寒冰剑描写」更新（3处）
   ├── 触发「冰系伏笔」更新（1处）
   └── 你点击了「全部接受」
```

他看到了"撤销这条因果链"的选项。

系统提示：

> *将撤销以下变更（按因果链回溯）：*
> - *「主角武器」属性恢复为"冰"*
> - *取消3处描写更新*
> - *取消伏笔更新*
>
> *注意：你今天新写的章节内容将保留，仅撤销武器相关改动。确认？*

林远点击确认。**5秒钟，一切恢复。**

**反思：建立新习惯**

他给「主角武器」加了标记：`#核心设定`，并把Policy调整为"严格模式"——以后任何修改都需要明确确认。

他也关掉了"批量接受"的默认设置，改用"逐条预览"。

在群里他发了一条：

> "AI搞砸了我的设定，但我5分钟就救回来了。工具再智能也要用脑子，但至少出错时有清晰的恢复路径。"

---

### 旅程3：张涛的有机体（技术开发者 - 成功路径）

**人物锚定**：张涛，28岁，创业公司技术负责人，现有工具是LangChain + 自研Agent框架。

**开场：框架的囚徒**

张涛的公司要做一个"情感陪伴AI"。用户的核心诉求是：**AI能记住我的故事、理解我的情绪、像一个真正的朋友。**

但现实很骨感。用LangChain搭的原型，每次对话都像和一个失忆症患者聊天。用户昨天说"我养了一只叫小黑的猫"，今天AI就问"你有宠物吗？"

他试过RAG、试过长上下文、试过Memory模块——都是缝缝补补。他开始怀疑：是不是AI就不可能"有状态"？

**发现：范式转换**

在GitHub上他看到一句话：

> *"AI本质无状态。是精密的上下文工程设计让AI有了状态。"*

这句话击中了他。他一直在用"增强记忆"的思路，但真正的问题不是记忆，是**状态设计**。

他注册了账号，选择"从空白开始"。

**构建：设计存在，而非编排动作**

张涛发现，这不是在"编程"，而是在"设计一个存在"。

他创建了几个核心"器官"（Context Unit）：
- **用户画像**：姓名、年龄、重要事件、性格标签
- **情感状态**：当前情绪、敏感话题、最近关注
- **记忆库**：重要对话片段、用户分享的生活细节

他用不同颜色的"边"连接它们：
- 蓝色（Reference）：AI回复时参考用户画像
- 紫色（Activation）：用户提到敏感话题时，触发情感状态更新

他配置了一个Agent负责「情感状态」维护，规则是：每次对话后根据内容更新情绪标签。

**第一个"哇"（测试）**

张涛开始测试：

*用户："今天又被老板骂了。"*

他看系统日志——Agent自动更新了情感状态：`当前情绪: 沮丧, 压力来源: 工作`。

AI的回复明显更加温柔："被骂的感觉确实很糟糕。愿意说说发生了什么吗？"

他继续测试。当用户提到"我家猫"时，AI自动关联到之前记录的"用户有一只叫小黑的猫"，回复里提到了小黑的名字。

**"它在'记住'用户。"**

**深度使用：导出为产品**

两周后，张涛完成了有机体设计。

他使用"自动化模式"导出——设置了触发条件（收到用户消息）、自动确认策略（低风险自动通过）、基础监控。

现在这个有机体可以独立运行，持续陪伴用户。

**结局：新的可能**

他把这套设计做成了公司的核心产品架构。在技术博客写道：

> "我们不再是在'编程'AI，而是在'设计'AI的存在。终于可以设计一个真正'活着'的AI，而不是一堆流程节点。"

---

### 旅程4：世界观组的协作（企业团队 - 成功路径）

**人物锚定**：游戏世界观组，5人团队——主策划陈刚（权威源）+ 3名策划（维护者）+ 1名AI协调员。现有工具是飞书文档 + 评审会议。

**开场：失控的设定**

周会上，陈刚问："精灵族的核心能力到底是什么？"

沉默。

策划A说："我那版是'擅长弓术'。"
策划B说："我改过了，是'擅长自然魔法'。"
策划C说："上周开会定的是'擅长治愈'啊。"

陈刚叹气。这种对话每周都在发生。五个人同时维护几百个种族、势力、地点的设定，飞书文档版本混乱，没人知道哪个是"官方版本"。

**转型：按责任分配变量**

技术负责人推荐了一个工具。陈刚决定试试。

第一步是配置权限——按职责分配变量责任：
- 策划A：人族相关（权威源）
- 策划B：妖族相关（权威源）
- 策划C：势力关系（权威源）
- 陈刚：全局设定（超级权限）
- AI协调员：一致性检查配置

每个人导入自己负责的内容。系统自动识别引用关系——"精灵族"被"第一次种族战争"引用，"龙脊山脉"被"矮人王国"引用……

**第一个"哇"（自动通知）**

策划B修改了"九尾狐族"的能力描述。

几秒钟后：

- **策划C**收到通知：*「你负责的「妖族联盟」引用了「九尾狐族」，该设定已被修改，请检查是否需要更新。」*
- **陈刚**收到通知：*「九尾狐族能力变更，受影响的关联设定：2个。需要您确认传播。」*

陈刚看到这一幕，笑了：**"终于不用在群里喊'我改了XX'了。"**

**冲突场景：同时编辑**

周五下午，策划A和策划B同时在编辑"人妖战争起因"——他们没有互相通知。

策划A改为："因为人族皇帝的贪婪"
策划B改为："因为妖族领地被侵占"

两人几乎同时点击保存。系统弹出冲突提示：

> *检测到编辑冲突*
>
> *「人妖战争·起因」被两人同时修改：*
> - *策划A: "人族皇帝的贪婪"*
> - *策划B: "妖族领地被侵占"*
>
> *请选择：[A版本] [B版本] [合并编辑] [提交给陈刚决定]*

两人在群里喊："你也在改这个？"

他们选择提交给陈刚。陈刚看到并排对比后，选择了"合并编辑"：

> "战争起因是复杂的——人族皇帝有领土野心，直接导火索是一次妖族领地被误伤事件。"

**结局：知识资产沉淀**

两个月后，团队做了对比：

| 指标         | 使用前 | 使用后 |
| ------------ | ------ | ------ |
| 每周设定争议 | 8-10次 | 1-2次  |
| 评审会时长   | 3小时  | 1小时  |
| 新人上手时间 | 2周    | 3天    |

陈刚在周会总结：**"每个人负责自己的模块，改动自动同步，再也不用开会对设定了。"**

---

### 旅程5：消费者视角（价值验证的下游证据）

**说明**：这不是平台用户的旅程，而是验证有机体输出价值的"下游证据"。

**场景A：小说读者**

读者小明追了林远的小说6个月。他在评论区写道：

> "追了这么久，发现作者真的很用心。前面铺垫的伏笔后面都回收了，角色性格前后一致，就连配角的行为逻辑都很连贯。"

林远截图发到朋友圈："这就是用这个工具的意义。"

**场景B：情感陪伴用户**

张涛的产品上线内测。一个用户反馈：

> "它怎么记得我上周说工作压力大？今天我说升职了，它说'看来坚持下来是值得的'。感觉它真的认识我。"

张涛把这条反馈截图给团队："这是我们验证的核心——用户感知到AI'有状态'。"

---

### 旅程6：张涛的集成调试（技术开发者 - 边缘场景）

*[V1.5+ 补充：覆盖导出有机体后的集成调试、API错误排查场景]*

---

### 旅程7：林远的自助排查（独立创作者 - 支持/故障排除）

**开场：AI突然"变傻"了**

使用系统一个月后，林远发现AI助手突然变得很奇怪——每次写作时，AI给的建议都不着调，总是提到一些他根本没写过的角色名字。

"小青是谁？我的小说里根本没有这个角色！"

他以为是AI模型的问题，准备去群里抓狂。

**转折：发现诊断入口**

他在界面右上角发现了一个"系统状态"图标，点开后看到：

> *系统健康检查*
> - Context Units: 正常
> - 传播引擎: 正常
> - **Agent「引用识别」: 配置异常** ← 问题在这里！
> - Agent「一致性检查」: 正常

他点击「引用识别Agent」的警告标记，系统显示：

> *检测到配置异常：该Agent的规则中引用了不存在的Context Unit「官方角色库」。*
> *这可能导致Agent产生不相关的建议。*

"官方角色库？我从来没建过这个东西啊……"

**排查：溯源日志定位问题**

他点击"查看变更历史"，系统展示了这个Agent配置的溯源日志：

```
配置变更历史：

初始配置 (1月15日) - 模板默认
修改识别规则 (1月18日) - 你手动调整
规则覆盖 (1月22日) - 批量导入操作 ← 问题来源
```

林远想起来了1月22日他尝试导入一个网上找的"角色库模板"，那个模板里有个「官方角色库」的引用，导入时把Agent配置也覆盖了。

**解决：配置回滚**

系统提示：

> *可以将该Agent配置回滚到1月18日的版本（你的最后一次手动调整），或者恢复到模板默认配置。*
>
> *[回滚到1月18日] [恢复模板默认] [手动编辑]*

林远点击"回滚到1月18日"。

3秒后，Agent状态变回正常。他写了一段测试内容，AI建议恢复正常了。

**反思：建立新习惯**

林远学到了两件事：

1. **导入外部内容要检查影响** — 以后导入前先查看"将被覆盖的配置"
2. **系统状态面板很有用** — 以后遇到奇怪问题先看这里

他在笔记里写了一条：

> "工具的溯源功能比想象中有用。以前用其他工具出问题只能抽卡重来，这里能精确定位到哪一步出了问题。"

---

### Journey Requirements Summary

#### 能力需求映射

| 旅程               | 揭示的核心能力                         | 对应PRD Scope                         |
| ------------------ | -------------------------------------- | ------------------------------------- |
| 林远-成功路径      | 自动引用识别、变更传播提示、一致性检查 | MAV：Context Unit + 四种边 + 小说模板 |
| 林远-错误恢复      | 因果链可视化、因果链撤销、Policy配置   | MAV：因果链（基础版）+ 确认机制       |
| 张涛-成功路径      | 从空白构建、边类型配置、自动化模式导出 | MAV：三种运行模式 + 自动化配置        |
| 世界观组-成功+冲突 | 权限配置、变更通知、冲突检测与解决     | MAV：多人工作台（基础）               |
| 消费者视角         | 有机体输出质量验证                     | 成功指标：状态一致性满意度            |
| 张涛-集成调试      | API错误诊断、导出调试                  | V1.5+：开发者体验增强                 |
| 林远-自助排查      | 系统诊断、Agent配置审查、溯源日志、配置回滚 | MAV：Event Sourcing + 系统状态面板    |

#### 与PRD指标的对齐验证

| PRD指标              | 旅程中的验证点                                                   |
| -------------------- | ---------------------------------------------------------------- |
| 首次"哇"≤10分钟      | 林远：<3分钟（自动识别关联）；张涛：测试阶段（情感状态自动更新） |
| 第一个关联≤3分钟     | 林远旅程明确展示                                                 |
| AI建议采纳率≥60%     | 林远深度使用阶段展示                                             |
| 冲突解决≤5分钟       | 世界观组冲突场景展示                                             |
| 错误后继续使用率≥90% | 林远错误恢复旅程展示                                             |
| 问题平均诊断时间≤15分钟 | 林远自助排查旅程展示（从发现异常到解决）                           |

---

## Domain-Specific Requirements

### Compliance & Regulatory

#### 数据隐私策略

基于项目哲学"高度用户自定义"和"人类最终决策权"，我们采用**本地优先架构**：

| 模式 | 部署方式 | 数据存储 | 适用场景 |
|------|----------|----------|----------|
| **本地模式** | 单机运行 | 本地 SQLite/文件系统 | MAV 默认；个人创作者 |
| **P2P 协作** | 点对点同步 | 本地 + 加密同步 | V1.5+；小团队协作 |
| **企业自托管** | Docker/K8s 部署 | 企业自有服务器 | 企业版；数据合规要求 |
| **官方云服务** | SaaS | 平台托管（加密） | V2.0+；轻量用户 |

#### 内容审核策略

| 策略 | 说明 | 适用场景 |
|------|------|----------|
| **零审核** | 系统不介入内容审查 | 本地优先产品；默认策略 |
| **可选自检** | 官方模板可配置自检 Agent | 用户自愿使用 |
| **企业合规** | 企业部署时可对接外部审核 | 企业版插件 |

#### 知识产权

| 问题 | 策略 |
|------|------|
| 用户创作内容归属 | 完全归用户所有，平台不主张任何权利 |
| 模板分享协议 | 默认 MIT 协议，用户可自定义 |
| 基于模板创作的衍生作品 | 归创作者所有，遵循模板协议要求 |
| 官方模板知识产权 | 开源可自由使用，鼓励社区改进 |

### Technical Constraints

#### 本地优先架构约束

```yaml
核心约束:
  - 数据首先存储本地，云端同步为可选
  - 用户完全拥有数据，可随时导出完整项目
  - 离线状态下核心功能可用（除协作功能）
  - 云端同步必须端到端加密
```

#### 反馈回路安全约束

> 详细约束规则见 Risk Mitigations → 设计时验证机制 → 反馈回路显式声明

核心原则：所有反馈回路必须显式声明安全参数（max_iterations、timeout_ms 等）

#### 四种确认模式完整配置

```yaml
确认策略配置:
  # 按 Tag 配置（默认策略）
  tag_policies:
    - tag: "#核心设定"
      confirmation: strict          # 严格模式：每个变更都需确认
      # 特点：最严格的确认级别，适用于关键业务数据

    - tag: "#重要变量"
      confirmation: confirm_required # 需确认模式
      # 行为：等同 strict，每个变更都需确认
      # 语义用途：用于明确标识"此变量必须由特定角色确认"
      # 示例：涉及多部门协作的 Unit，必须经部门负责人确认
      # 与 strict 的区别：confirm_required 强调"必须由特定 Authority Source 确认"
      # 而 strict 仅表示"需要确认"，不指定确认人

    - tag: "#常规内容"
      confirmation: batch_queue     # 批量模式：可批量接受建议
      # 适用：日常维护、低风险的批量操作

    - tag: "#草稿"
      confirmation: yolo           # YOLO 模式：自动接受，无需确认
      # 适用：快速迭代、实验性内容，用户明确选择信任 AI

  # 按 Unit 配置（覆盖 Tag 配置）
  unit_override: true

  # 混合维护者时的策略
  multi_maintainer_policy:
    primary: Agent-A      # 一级维护者：提出变更建议
    secondary: Agent-B    # 二级维护者：审查一级建议
    final_authority: user  # 最终决策权：人工确认
    flow: primary → secondary → final_authority
```

#### 多模型/多后端配置约束

支持按变量/卡片粒度配置不同模型和 API 后端，实现"质量/成本/速度"的自主控制。

**核心设计原则**

| 原则 | 说明 |
|------|------|
| 统一接口 | 所有 Provider 遵循 OpenAI-compatible API 标准 |
| 分层解耦 | ModelManager → Provider → Model 三层架构 |
| 水平扩展 | 通过配置文件即可添加新 Provider，无需修改核心代码 |
| 凭证隔离 | 支持 Provider 级和 Model 级两套凭证配置 |

**优先支持的 Coding 套餐（MAV 阶段）**

| 提供商 | 套餐类型 | Base URL | 特点 |
|--------|----------|----------|------|
| 智谱AI | GLM Coding Plan | `https://open.bigmodel.cn/api/paas/v4` | 性价比高，Claude Pro 套餐的1/3价格 |
| 月之暗面 | Kimi Coding | `https://api.moonshot.cn/v1` | 长上下文（200K） |
| MiniMax | MiniMax Coding | `https://api.minimax.chat/v1` | 中文优化 |

**Provider 配置格式**

```yaml
providers:
  zhipu:  # 智谱 Coding 套餐（优先支持）
    name: "智谱AI"
    base_url: "https://open.bigmodel.cn/api/paas/v4"
    api_key: "${ZHIPU_API_KEY}"
    default_model: "glm-4.5-coding"
    timeout: 30000
    max_retries: 3
    models:
      - id: "glm-4.7-coding"
        context_window: 128000
        cost_per_1k_input: 0.002

  kimi:  # Kimi Coding 套餐（优先支持）
    name: "月之暗面"
    base_url: "https://api.moonshot.cn/v1"
    api_key: "${KIMI_API_KEY}"

  local:  # 本地模型（隐私优先场景）
    name: "本地模型"
    base_url: "http://localhost:11434/v1"
```

**按 Unit 配置模型策略**

```yaml
unit_model_config:
  - unit_tag: "#核心设定"
    provider: "zhipu"
    model: "glm-4.7-coding"
    temperature: 0.3

  - unit_tag: "#常规内容"
    provider: "zhipu"
    model: "glm-4.5-coding"

  - unit_tag: "#草稿"
    provider: "local"
    model: "qwen2.5-coder:7b"
```

**成本控制机制**

| 机制 | 说明 |
|------|------|
| Token 预算 | 按 Unit/Tag 设置月度 Token 上限 |
| 成本告警 | 达到预算 80% 时警告，100% 时自动降级 |
| 智能降级 | 主模型不可用/超预算时，自动切换到备用 Provider |
| 成本追踪 | 每个 Unit 的模型调用成本独立统计 |

**智能降级链配置**

```yaml
fallback_chain:
  - provider: zhipu
    model: glm-4.7-coding
  - provider: zhipu
    model: glm-4.5-coding
  - provider: local
    model: qwen2.5-coder
```

**参考实现**

借鉴以下开源项目的设计：
- **Cherry Studio** (CherryHQ/cherry-studio): Provider Registry、智能路由
- **Dify** (langgenius/dify): Model Runtime 三层架构、凭证管理

### Integration Requirements

#### 存储适配层接口

从第一天预留统一的存储适配接口：

```yaml
StorageAdapter:
  type: local_sqlite | p2p_crdt | self_hosted | cloud
  # 统一接口，支持不同阶段切换，无需重构代码

SyncAdapter:
  - offline:          # 单机模式（MAV 默认）
  - p2p:              # 点对点同步（V1.5+）
  - relay:            # 中继同步（V1.5+，用于 NAT 穿透）
  - centralized:      # 中心化同步（V2.0+ 官方云）
```

#### 协作技术选型

**选型决策：方案 C（三者都支持）**

| 阶段 | 技术方案 | 实现方式 | 适用场景 |
|------|----------|----------|----------|
| MAV | 本地 SQLite | 单机运行，可选加密云同步（iCloud/Google Drive） | 个人创作者 |
| V1.5 | P2P + CRDT | 点对点同步，端到端加密，无需中心服务器 | 小团队协作 |
| V2.0 | 官方云服务 | SaaS + 企业自托管选项 | 轻量用户/企业 |

#### 导出与分享机制

**三种导出/分享模式**：

| 模式 | 内容 | 用途 |
|------|------|------|
| **模板分享** | Unit类型定义、Agent规则、Policy配置 | 分享配置框架供他人使用 |
| **项目克隆** | 所有Unit + 完整历史 + 配置 | 团队新成员、完整备份 |
| **有机体导出** | 特定Snapshot + 运行配置 | 部署为自动化服务 |

**有机体配置包格式（概念版）**：

```yaml
organism_package:
  version: "1.0.0"
  schema_version: "2.0"

  metadata:
    name: "模板名称"
    author: "作者"
    description: "描述"
    license: "MIT"  # 可自定义

  config:
    unit_types: [...]      # Unit 类型定义
    edge_types: [...]      # 边类型配置
    agents: [...]          # Agent 规则
    template_units: [...]  # 预设 Unit

  sharing:
    allow_fork: true           # 允许基于此创建新模板
    allow_modification: true   # 允许修改后重新分享
    attribution_required: true # 需要保留原作者署名
```

**设计原则：灵活字段**

有机体配置包采用"开放字段"设计，避免定死字段限制后续扩展：

| 特性 | 说明 |
|------|------|
| 扩展字段 | config 下允许任意自定义字段，遵循命名空间规则（如 `x_custom_field`） |
| 版本兼容 | 新版本读取旧格式时，未知字段保留但不处理；旧版本读取新格式时，忽略未知字段 |
| 模板继承 | 支持基于现有模板创建新模板，可覆盖或扩展任意字段 |
| 字段校验 | 仅校验核心必填字段（version, schema_version, metadata），其余字段由模板自行定义规则 |

### Risk Mitigations

#### 设计时验证机制

通过神经网络设计约束预防运行时冲突：

**1. 单一 Maintainer 原则**

核心规则：每个 Unit 同一时间只有一个 Maintainer（人、Agent 或混合）

| 原则 | 说明 | 实现方式 |
|------|------|----------|
| 目的 | 从根本上避免传统"同时编辑"冲突 | 设计时责任分配，而非运行时锁 |
| 单一性 | 一个 Unit 不可被多个 Maintainer 并行维护 | 静态检查强制约束 |
| 变更 | 更换 Maintainer 需显式交接流程 | 记录交接事件，确保可追溯 |
| 例外 | 二次审查机制中多级 Maintainer | 串行执行，非并行（见 Authority Source vs Maintainer） |

**2. 传播方向确定性**
```
错误设计：                    正确设计：
角色A ──→ 势力 ←── 角色B     角色A ──┐
   ↑                    ↑           ├─→ 【聚合节点】──→ 势力
   └──── 同时修改 ──────┘      角色B ──┘
规则：多对一关系必须通过"聚合节点"
```

**3. 层级传播约束**
```
角色卡 ──→ 势力卡 ──→ 章节卡 ──→ 世界大纲
   │          │          │
   └──── 层级递增，不可随意跨级 ────┘
```

**4. 循环引用检测与保护**

虽然现实创作中一般不存在合理的循环依赖，但系统必须提供检测和保护机制：

| 场景 | 检测时机 | 处理策略 |
|------|----------|----------|
| 设计时静态检查 | 构建依赖图时 | 检测到循环 → 预警并给出重构建议 |
| 运行时保护 | 传播执行时 | 遇到未检测到的循环 → 自动暂停 + 标记待处理 |

重构建议示例：
```
检测到循环依赖：角色A → 角色B → 势力关系 → 角色A
建议：将"势力关系"拆分为独立 Unit，角色A/B 均引用该 Unit
```

**5. Maintainer 负载均衡检查**

| 检查项 | 阈值 | 处理策略 |
|--------|------|----------|
| 单一 Maintainer 负责的 Unit 数 | 默认 ≤50 | 超过时警告，建议拆分或增加 Maintainer |
| 单一 Unit 的 Maintainer 数量 | 必须 =1 | 多人/多 Agent 同时维护同一 Unit 时强制修复 |
| Maintainer 响应时间 | 可配置 | 超过阈值时自动触发备用 Maintainer 或转入待处理队列 |

**6. 反馈回路显式声明**

借鉴人体神经系统的反馈机制，所有反馈回路必须显式声明安全参数：

```yaml
反馈回路配置:
  type: negative_feedback | positive_feedback
  max_iterations: 10              # 【必须】最大迭代次数，防止无限循环
  timeout_ms: 5000                # 【必须】单次反馈超时，防止阻塞

  # 根据类型配置：
  convergence_threshold: 0.01     # 【负反馈必须】收敛阈值
  divergence_limit: 100           # 【正反馈可选】发散上限，防止级联过度

限制说明:
  - MAV 阶段：仅支持负反馈（如一致性自动修正）
  - V1.5+：支持正反馈（如剧情连锁反应）
  - 必须配置项不可省略，系统拒绝执行未配置安全参数的反馈回路
  - 达到 max_iterations 未收敛：强制终止，标记为"需人工检查"
  - 达到 timeout_ms：中断当前迭代，记录状态，等待下一次触发
```

**7. 设计时静态检查分级**

| 冲突类型 | 检测时机 | 处理策略 |
|----------|----------|----------|
| **高危（数据一致性风险）** | 设计时 | **强制修复**后才能运行 |
| **中危（性能瓶颈）** | 设计时 | **警告提示**，建议优化 |
| **低危（建议优化）** | 设计时/运行时 | **提示**，不阻断 |
| **运行时异常** | 传播过程中 | **自动暂停** + 进入确认队列 |

#### 运行时降级策略

| 场景 | 策略 |
|------|------|
| 检测到潜在冲突 | 自动暂停传播，进入确认队列等待人工裁决 |
| 反馈回路未收敛 | 达到 max_iterations 后强制终止，标记为"需人工检查" |
| 网络同步失败 | 本地继续运行，标记为"离线模式"，恢复后自动同步 |

#### 责任边界

| 场景 | 责任归属 | 系统行为 |
|------|----------|----------|
| 用户采纳 AI 建议后出现问题 | **用户承担责任** | 确认界面明确提示"你即将接受此变更" |
| AI 未经确认自动修改（YOLO模式） | **用户承担责任** | 模式切换需二次确认 |
| 模板 Agent 给出不合理建议 | **模板设计者责任** | 提供模板版本更新 + 用户可覆盖配置 |
| 传播机制错误 | **平台责任** | 紧急修复 + 数据恢复 |

#### Authority Source vs Maintainer 机制

```yaml
权限分离设计:
  Authority Source:
    - 定义：冲突时的最终决策人
    - 角色：人类/外部文档/系统/Agent
    - 权力：否决变更、强制落盘特定版本

  Maintainer:
    - 定义：负责提出变更建议
    - 角色：Agent/人类/规则
    - 权力：生成 ChangeSet、提交建议、无权强制落盘

  二次审查机制:
    - 适用：高价值/高风险 Unit
    - 流程：一级 Maintainer 提交 → 二级 Maintainer 审查 → Authority Source 确认
    - 特点：串行执行，前一级完成后才进入下一级
```
